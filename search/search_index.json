{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Issue and verify universally-accepted digital credentials. \u00b6 Trinsic is the proof of anything platform. We make it easy for people and organizations to prove things about themselves with technology instead of paper documents. Our software is based on Decentralized Identifiers (DIDs) and Verifiable Credentials (VCs), a new digital identity standard. Using Trinsic, organizations and their customers share data between each other in a trustworthy, standardized, and privacy-preserving way without requiring a centralized server or database. We make all of this possible by signing, sharing and storing verifiable data within identity wallets owned by individuals. People can easily share them with others to prove things about themselves anywhere. Learn how to issue and verify universally-accepted digital credentials so that anywhere people go online or in-person, they can simply tap their phone, prove who they are, and get what they need. Our Products \u00b6 Trinsic Core \u00b6 Trinsic Core is infrastructure for digital trust. It's our set of APIs for sending verifiable data between digital identity wallets. Core gives people and organizations the ability to easily and securely prove things about themselves with digital credentials. With Core, you can transform credentials, licenses, passes, and certificates into a W3C standard format that can be exchanged digitally and verified instantly by anyone called a \"verifiable credential\". Trinsic Ecosystems \u00b6 A layer built on top of Core, Trinsic Ecosystems is a product for organizations that want to build an ecosystem of different issuers, holders, and verifiers of credentials. By ecosystem, we mean a network of companies and consumers that need to be able to securely share and instantly verify data. At Trinsic, we call the organizations that bring together these ecosystems of companies and customers \"providers\" since they are providing digital trust to the ecosystem through Trinsic's infrastructure. Get Started in 15 Minutes Want to get started using digital credentials quickly? Try our tutorial to get a conceptual walkthrough of a common use case.","title":"Home"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#issue-and-verify-universally-accepted-digital-credentials","text":"Trinsic is the proof of anything platform. We make it easy for people and organizations to prove things about themselves with technology instead of paper documents. Our software is based on Decentralized Identifiers (DIDs) and Verifiable Credentials (VCs), a new digital identity standard. Using Trinsic, organizations and their customers share data between each other in a trustworthy, standardized, and privacy-preserving way without requiring a centralized server or database. We make all of this possible by signing, sharing and storing verifiable data within identity wallets owned by individuals. People can easily share them with others to prove things about themselves anywhere. Learn how to issue and verify universally-accepted digital credentials so that anywhere people go online or in-person, they can simply tap their phone, prove who they are, and get what they need.","title":"Issue and verify universally-accepted digital credentials."},{"location":"#our-products","text":"","title":"Our Products"},{"location":"#trinsic-core","text":"Trinsic Core is infrastructure for digital trust. It's our set of APIs for sending verifiable data between digital identity wallets. Core gives people and organizations the ability to easily and securely prove things about themselves with digital credentials. With Core, you can transform credentials, licenses, passes, and certificates into a W3C standard format that can be exchanged digitally and verified instantly by anyone called a \"verifiable credential\".","title":"Trinsic Core"},{"location":"#trinsic-ecosystems","text":"A layer built on top of Core, Trinsic Ecosystems is a product for organizations that want to build an ecosystem of different issuers, holders, and verifiers of credentials. By ecosystem, we mean a network of companies and consumers that need to be able to securely share and instantly verify data. At Trinsic, we call the organizations that bring together these ecosystems of companies and customers \"providers\" since they are providing digital trust to the ecosystem through Trinsic's infrastructure. Get Started in 15 Minutes Want to get started using digital credentials quickly? Try our tutorial to get a conceptual walkthrough of a common use case.","title":"Trinsic Ecosystems"},{"location":"early-adopter/","text":"Introducing Trinsic Ecosystems \u00b6 For development teams ready to integrate verifiable credentials for a specific industry or use case, Trinsic Ecosystems has been built specifically for you. We're currently in beta with a small group of customers. If you'd like to join the beta for Trinsic Ecosystems, please reach out! Simply fill out the form below, and we'll get in touch. Sign Up","title":"Before You Start"},{"location":"early-adopter/#introducing-trinsic-ecosystems","text":"For development teams ready to integrate verifiable credentials for a specific industry or use case, Trinsic Ecosystems has been built specifically for you. We're currently in beta with a small group of customers. If you'd like to join the beta for Trinsic Ecosystems, please reach out! Simply fill out the form below, and we'll get in touch. Sign Up","title":"Introducing Trinsic Ecosystems"},{"location":"roadmap/","text":"Roadmap \u00b6 SDKs \u00b6 Available SDKs \u00b6 .NET Node Python Web Java Coming Soon \u00b6 Android iOS Go Ruby","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#sdks","text":"","title":"SDKs"},{"location":"roadmap/#available-sdks","text":".NET Node Python Web Java","title":"Available SDKs"},{"location":"roadmap/#coming-soon","text":"Android iOS Go Ruby","title":"Coming Soon"},{"location":"support/","text":"Have a Question? \u00b6 Normally, the best way to ask quick questions is through the Trinsic Community slack channel . If you have a bug to report, please report it on the Github issues on our SDK. Contributions and additions to this docs site are always welcome. Finally, if you're interested in getting in touch with the team for any other reason, contact us at support@trinsic.id . We treat any feedback as gold.","title":"Ask a Question"},{"location":"support/#have-a-question","text":"Normally, the best way to ask quick questions is through the Trinsic Community slack channel . If you have a bug to report, please report it on the Github issues on our SDK. Contributions and additions to this docs site are always welcome. Finally, if you're interested in getting in touch with the team for any other reason, contact us at support@trinsic.id . We treat any feedback as gold.","title":"Have a Question?"},{"location":"android/","text":"Android Sample Application \u00b6 The Trinsic Android sample application makes it easy to interact with the Trinsic API. The sample application is located here Installation \u00b6 Clone the sdk-examples repository Open the folder sdk-examples/android in Android Studio Run gradle build for the first time, it will take a while, but it should pull down all the required .jar files You should be able to build and run the android application. There is an sdk-examples/android-controller application written in Python which allows you to issue credentials/verify proofs outside of the android application for demonstration purposes. Note If you want to included the two required Trinsic .jar files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle implementation target as shown below: def urlFile = { url , name -> File file = new File ( \"$buildDir/download/${name}.jar\" ) file . parentFile . mkdirs () if (! file . exists ()) { new URL ( url ). withInputStream { downloadStream -> file . withOutputStream { fileOut -> fileOut << downloadStream } } } files ( file . absolutePath ) } dependencies { // other dependencies implementation urlFile ( ' https : //github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0') implementation urlFile ( ' https : //github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1') } Next Steps \u00b6 Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API Java API Reference","title":"Android"},{"location":"android/#android-sample-application","text":"The Trinsic Android sample application makes it easy to interact with the Trinsic API. The sample application is located here","title":"Android Sample Application"},{"location":"android/#installation","text":"Clone the sdk-examples repository Open the folder sdk-examples/android in Android Studio Run gradle build for the first time, it will take a while, but it should pull down all the required .jar files You should be able to build and run the android application. There is an sdk-examples/android-controller application written in Python which allows you to issue credentials/verify proofs outside of the android application for demonstration purposes. Note If you want to included the two required Trinsic .jar files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle implementation target as shown below: def urlFile = { url , name -> File file = new File ( \"$buildDir/download/${name}.jar\" ) file . parentFile . mkdirs () if (! file . exists ()) { new URL ( url ). withInputStream { downloadStream -> file . withOutputStream { fileOut -> fileOut << downloadStream } } } files ( file . absolutePath ) } dependencies { // other dependencies implementation urlFile ( ' https : //github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0') implementation urlFile ( ' https : //github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1') }","title":"Installation"},{"location":"android/#next-steps","text":"Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API Java API Reference","title":"Next Steps"},{"location":"cli/","text":"The Trinsic CLI \u00b6 The Trinsic CLI makes it easy to interact with the Trinsic API from your terminal. You can get the CLI on homebrew or build the CLI from source on Github . It contains all the commands of Trinsic's SDKs and makes them interactive. Installation \u00b6 MacOS and Linux Windows From source We use homebrew to distribute the CLI packages for MacOS and Linux. Install Homebrew Then run these commands to install the Trinsic CLI brew tap trinsic-id/tap brew install trinsic-cli The CLI can be installed using Winget winget install okapi winget install trinsic The CLI can also be built from source. This requires the Rustup toolchain installed on your system. Once installed, run this command in terminal: cargo +nightly install --git https://github.com/trinsic-id/sdk trinsic To verify that the CLI has been installed successfully, try running: trinsic --help Next Steps \u00b6 Once the CLI is installed, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference. For more information about the CLI, read the configuration guide Start Walkthrough Explore API","title":"Trinsic CLI"},{"location":"cli/#the-trinsic-cli","text":"The Trinsic CLI makes it easy to interact with the Trinsic API from your terminal. You can get the CLI on homebrew or build the CLI from source on Github . It contains all the commands of Trinsic's SDKs and makes them interactive.","title":"The Trinsic CLI"},{"location":"cli/#installation","text":"MacOS and Linux Windows From source We use homebrew to distribute the CLI packages for MacOS and Linux. Install Homebrew Then run these commands to install the Trinsic CLI brew tap trinsic-id/tap brew install trinsic-cli The CLI can be installed using Winget winget install okapi winget install trinsic The CLI can also be built from source. This requires the Rustup toolchain installed on your system. Once installed, run this command in terminal: cargo +nightly install --git https://github.com/trinsic-id/sdk trinsic To verify that the CLI has been installed successfully, try running: trinsic --help","title":"Installation"},{"location":"cli/#next-steps","text":"Once the CLI is installed, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference. For more information about the CLI, read the configuration guide Start Walkthrough Explore API","title":"Next Steps"},{"location":"cli/config/","text":"Configuration \u00b6 The CLI stores its configuration in the user's home directory in ~/.trinsic/ . This directory contains the main configuration file config.toml and all the profile data. Show Configuration \u00b6 To print the current configuration file in the terminal use: trinsic config --show Typical configuration file may look like this: [server] address = \"https://prod.trinsic.cloud\" [profile] default = \"my_profile\" Update Configuration Entry \u00b6 To change the configuration values, use the config subcommand with the attribute and its value. trinsic config <attribute_name> <attribute_value> The following attributes are currently supported: server-address Updates the default server address the CLI communicates trinsic config --server-address https://example.com/ profile-default Updates the default profile used with the CLI trinsic config --profile-default alice","title":"Configuration"},{"location":"cli/config/#configuration","text":"The CLI stores its configuration in the user's home directory in ~/.trinsic/ . This directory contains the main configuration file config.toml and all the profile data.","title":"Configuration"},{"location":"cli/config/#show-configuration","text":"To print the current configuration file in the terminal use: trinsic config --show Typical configuration file may look like this: [server] address = \"https://prod.trinsic.cloud\" [profile] default = \"my_profile\"","title":"Show Configuration"},{"location":"cli/config/#update-configuration-entry","text":"To change the configuration values, use the config subcommand with the attribute and its value. trinsic config <attribute_name> <attribute_value> The following attributes are currently supported: server-address Updates the default server address the CLI communicates trinsic config --server-address https://example.com/ profile-default Updates the default profile used with the CLI trinsic config --profile-default alice","title":"Update Configuration Entry"},{"location":"cli/demo/","text":"Trinsic CLI Demo \u00b6 Steps to Run \u00b6 Click the green Run button Follow walkthrough Note: If you resize this window, make sure to reload the page. If not, the CLI will have display problems.","title":"Trinsic CLI Demo"},{"location":"cli/demo/#trinsic-cli-demo","text":"","title":"Trinsic CLI Demo"},{"location":"cli/demo/#steps-to-run","text":"Click the green Run button Follow walkthrough Note: If you resize this window, make sure to reload the page. If not, the CLI will have display problems.","title":"Steps to Run"},{"location":"dotnet/","text":"The Trinsic C# / .NET SDK \u00b6 The Trinsic C# / .NET SDK makes it easy to interact with the Trinsic API from your .NET application. The most recent version of the library can be found on NuGet. The Trinsic SDK supports .NET applications written in C#, VB.NET, and F# that utilize any supported version of .NET Core. You can also find the SDKs source on Github . Supported runtimes .NET targets for iOS, Android, and Blazor are fully supported using the same package dependencies via .NET 6. Installation in a new project \u00b6 Add the required dependencies from Nuget.org Package Manager .NET CLI PackageReference PM> Install-Package Trinsic dotnet add package Trinsic --prerelease dotnet add package Okapi.Net --prerelease <PackageReference Include=\"Trinsic\" /> <PackageReference Include=\"Okapi.Net\" /> This will not be required in future version and only package Trinsic can be used. Configuration \u00b6 var myAccountService = new AccountService ( _options ); var myProfile = await myAccountService . SignInAsync ( new ()); myAccountService . Options . AuthToken = myProfile ; var output = await myAccountService . GetInfoAsync (); Assert . NotNull ( output ); Next Steps \u00b6 Once the .NET SDK package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API C# API Reference","title":"C#"},{"location":"dotnet/#the-trinsic-c-net-sdk","text":"The Trinsic C# / .NET SDK makes it easy to interact with the Trinsic API from your .NET application. The most recent version of the library can be found on NuGet. The Trinsic SDK supports .NET applications written in C#, VB.NET, and F# that utilize any supported version of .NET Core. You can also find the SDKs source on Github . Supported runtimes .NET targets for iOS, Android, and Blazor are fully supported using the same package dependencies via .NET 6.","title":"The Trinsic C# / .NET SDK"},{"location":"dotnet/#installation-in-a-new-project","text":"Add the required dependencies from Nuget.org Package Manager .NET CLI PackageReference PM> Install-Package Trinsic dotnet add package Trinsic --prerelease dotnet add package Okapi.Net --prerelease <PackageReference Include=\"Trinsic\" /> <PackageReference Include=\"Okapi.Net\" /> This will not be required in future version and only package Trinsic can be used.","title":"Installation in a new project"},{"location":"dotnet/#configuration","text":"var myAccountService = new AccountService ( _options ); var myProfile = await myAccountService . SignInAsync ( new ()); myAccountService . Options . AuthToken = myProfile ; var output = await myAccountService . GetInfoAsync (); Assert . NotNull ( output );","title":"Configuration"},{"location":"dotnet/#next-steps","text":"Once the .NET SDK package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API C# API Reference","title":"Next Steps"},{"location":"go/","text":"The Trinsic Go SDK \u00b6 The Trinsic Go SDK makes it easy to interact with the Trinsic API from any Go application. The most recent version of the library can be found on ____. You can find the SDKs source on Github . Installation and Configuration \u00b6 NOTE: Windows installation is possible, but requires jumping through a few hoops. More details to come later. Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here You need to have CGO configured for the okapi native binary link Issue the following command: go install github.com/trinsic-id/sdk/go@latest To test the installation, try the following go code: opts , err := sdk . NewServiceOptions () if err != nil { panic ( \"could not create service options\" ) } accountService , err := sdk . NewAccountService ( opts ) if err != nil { panic ( \"Account service not created\" ) } profile , _ , err := accountService . SignIn ( context . Background (), & sdkproto . SignInRequest {}) if err != nil { panic ( \"Sign in failed!\" ) } fmt . Printf ( \"%v\\n\" , profile ) Next Steps \u00b6 Once the go package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API Go API Reference","title":"Go"},{"location":"go/#the-trinsic-go-sdk","text":"The Trinsic Go SDK makes it easy to interact with the Trinsic API from any Go application. The most recent version of the library can be found on ____. You can find the SDKs source on Github .","title":"The Trinsic Go SDK"},{"location":"go/#installation-and-configuration","text":"NOTE: Windows installation is possible, but requires jumping through a few hoops. More details to come later. Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here You need to have CGO configured for the okapi native binary link Issue the following command: go install github.com/trinsic-id/sdk/go@latest To test the installation, try the following go code: opts , err := sdk . NewServiceOptions () if err != nil { panic ( \"could not create service options\" ) } accountService , err := sdk . NewAccountService ( opts ) if err != nil { panic ( \"Account service not created\" ) } profile , _ , err := accountService . SignIn ( context . Background (), & sdkproto . SignInRequest {}) if err != nil { panic ( \"Sign in failed!\" ) } fmt . Printf ( \"%v\\n\" , profile )","title":"Installation and Configuration"},{"location":"go/#next-steps","text":"Once the go package is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API Go API Reference","title":"Next Steps"},{"location":"ios/","text":"The Trinsic Swift SDK \u00b6 The Trinsic Swift SDK makes it easy to interact with the Trinsic API from any application built for iOS, MacCatalyst, or MacOS. The SDK is available for Swift Package Manager and can be added in your dependency section in Package.swift as follows: swift dependencies: [ .package(name: \"Trinsic\", url: \"https://github.com/trinsic-id/sdk-swift\", branch: \"main\") ], You can find more details, source code, and tests for the Swift SDK at trinsic-id/sdk-swift .","title":"iOS"},{"location":"ios/#the-trinsic-swift-sdk","text":"The Trinsic Swift SDK makes it easy to interact with the Trinsic API from any application built for iOS, MacCatalyst, or MacOS. The SDK is available for Swift Package Manager and can be added in your dependency section in Package.swift as follows: swift dependencies: [ .package(name: \"Trinsic\", url: \"https://github.com/trinsic-id/sdk-swift\", branch: \"main\") ], You can find more details, source code, and tests for the Swift SDK at trinsic-id/sdk-swift .","title":"The Trinsic Swift SDK"},{"location":"java/","text":"The Trinsic Java SDK \u00b6 The Trinsic Java SDK makes it easy to interact with the Trinsic API from any Java application. The most recent version of the package is found on the Github Release . You can find the SDKs source on Github . Installation \u00b6 Add the urlFile code shown below to your build.gradle . Add the implementations as shown below to your build.gradle . Run gradle build to download the required jar files. This can take some time. Configuration \u00b6 Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here If you install to a different location for debugging, use the environment variable LD_LIBRARY_PATH , even on Windows. Note If you want to included the two required Trinsic .jar files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle implementation target as shown below: def urlFile = { url , name -> File file = new File ( \"$buildDir/download/${name}.jar\" ) file . parentFile . mkdirs () if (! file . exists ()) { new URL ( url ). withInputStream { downloadStream -> file . withOutputStream { fileOut -> fileOut << downloadStream } } } files ( file . absolutePath ) } dependencies { // other dependencies implementation urlFile ( ' https : //github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0') implementation urlFile ( ' https : //github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1') } Next Steps \u00b6 Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API Java API Reference","title":"Java"},{"location":"java/#the-trinsic-java-sdk","text":"The Trinsic Java SDK makes it easy to interact with the Trinsic API from any Java application. The most recent version of the package is found on the Github Release . You can find the SDKs source on Github .","title":"The Trinsic Java SDK"},{"location":"java/#installation","text":"Add the urlFile code shown below to your build.gradle . Add the implementations as shown below to your build.gradle . Run gradle build to download the required jar files. This can take some time.","title":"Installation"},{"location":"java/#configuration","text":"Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here If you install to a different location for debugging, use the environment variable LD_LIBRARY_PATH , even on Windows. Note If you want to included the two required Trinsic .jar files in your own application (android or other java), be sure to copy the following lines. They allow you to specify a remote file location as a gradle implementation target as shown below: def urlFile = { url , name -> File file = new File ( \"$buildDir/download/${name}.jar\" ) file . parentFile . mkdirs () if (! file . exists ()) { new URL ( url ). withInputStream { downloadStream -> file . withOutputStream { fileOut -> fileOut << downloadStream } } } files ( file . absolutePath ) } dependencies { // other dependencies implementation urlFile ( ' https : //github.com/trinsic-id/okapi/releases/download/v1.4.0/trinsic-okapi-1.4.0.jar', 'trinsic-okapi-1.4.0') implementation urlFile ( ' https : //github.com/trinsic-id/sdk/releases/download/v1.4.0/trinsic-services-1.4.1.jar', 'trinsic-services-1.4.1') }","title":"Configuration"},{"location":"java/#next-steps","text":"Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API Java API Reference","title":"Next Steps"},{"location":"learn/credentials/","text":"What are Verifiable Credentials \u00b6 \"Verifiable Credentials\", or \"VCs\" are digital documents that conform to the W3C Verifiable Credential Data Model. VCs provide a standard for digitally issuing, holding, and verifying data about a subject. A verifiable credential is a set of tamper-evident claims and metadata that cryptographically prove who issued it. https://www.w3.org/TR/vc-data-model/ Verifiable credentials are unique from other kinds of digital documents because they enable you to verify the following things: The original issuing entity (the source of the data) It was issued to the entity presenting it (the subject of the data) It hasn't been tampered with (the veracity of the data) Whether the issuer revoked the credential as of a particular point in time (the status of the data) trust triangle Components of a Credential \u00b6 To break down the components of a credential, we'll use a digital driver's license as an example. Issuer DID \u00b6 As you can see from the diagram above, a verifier will only accept a credential if they trust its source. For example, in the United States a TSA agent will only let you on an airplane if you present a valid driver's license (or other gov ID); they do this because they trust the DMV or other agency that issued it. In order to validate where a credential came from, verifiers use the issuer's DID . Each new issuer is assigned an issuer DID. The issuer DID acts as a public-facing address or public key . In self-sovereign identity, these DIDs are usually written to a public blockchain, but other locations are possible, too. Each issuer DID has an associated private key which is used to cryptographically \"sign\" each issued credential. In fact, each attribute inside the credential is signed in this manner, allowing the holder of the credential to share only a subset of the attributes when desired. For example, someone could share their name and age from their driver's license without sharing the driver's license number, address, and hair color. Using the issuer DID and straightforward public-private key cryptography, anyone can verify the attributes in the credential were attested to by the issuer. Schema \u00b6 Each credential needs a template so the data can be shared and interpreted correctly. That template is called a Schema. Schemas are the general structure of the credential. In our example, they tell us what information must be included on the driver's license in order for it to be valid, like Full name, Address, Eye color, etc. In short, they are the attributes that you want to include in this credential. Example: \u00b6 { \"$schema\" : \"http://json-schema.org/draft-07/schema#\" , \"description\" : \"Email\" , \"type\" : \"object\" , \"properties\" : { \"emailAddress\" : { \"type\" : \"string\" , \"format\" : \"email\" } }, \"required\" : [ \"emailAddress\" ], \"additionalProperties\" : false } Schemas are nonproprietary; any issuer can view/use the schemas written by any other issuer. We abstract schema creation away into the same action as creation of a credential template. Keep reading to read how to create a schema and credential template. Verifications \u00b6 Passes are documents generated from credentials that contain only the information required to be verified. They can be generated in advance or in real-time. Passes minimize the information about you that is shared with third parties. Credentials are signed using BLS keys. These create from the credential fields.","title":"Credentials"},{"location":"learn/credentials/#what-are-verifiable-credentials","text":"\"Verifiable Credentials\", or \"VCs\" are digital documents that conform to the W3C Verifiable Credential Data Model. VCs provide a standard for digitally issuing, holding, and verifying data about a subject. A verifiable credential is a set of tamper-evident claims and metadata that cryptographically prove who issued it. https://www.w3.org/TR/vc-data-model/ Verifiable credentials are unique from other kinds of digital documents because they enable you to verify the following things: The original issuing entity (the source of the data) It was issued to the entity presenting it (the subject of the data) It hasn't been tampered with (the veracity of the data) Whether the issuer revoked the credential as of a particular point in time (the status of the data) trust triangle","title":"What are Verifiable Credentials"},{"location":"learn/credentials/#components-of-a-credential","text":"To break down the components of a credential, we'll use a digital driver's license as an example.","title":"Components of a Credential"},{"location":"learn/credentials/#issuer-did","text":"As you can see from the diagram above, a verifier will only accept a credential if they trust its source. For example, in the United States a TSA agent will only let you on an airplane if you present a valid driver's license (or other gov ID); they do this because they trust the DMV or other agency that issued it. In order to validate where a credential came from, verifiers use the issuer's DID . Each new issuer is assigned an issuer DID. The issuer DID acts as a public-facing address or public key . In self-sovereign identity, these DIDs are usually written to a public blockchain, but other locations are possible, too. Each issuer DID has an associated private key which is used to cryptographically \"sign\" each issued credential. In fact, each attribute inside the credential is signed in this manner, allowing the holder of the credential to share only a subset of the attributes when desired. For example, someone could share their name and age from their driver's license without sharing the driver's license number, address, and hair color. Using the issuer DID and straightforward public-private key cryptography, anyone can verify the attributes in the credential were attested to by the issuer.","title":"Issuer DID"},{"location":"learn/credentials/#schema","text":"Each credential needs a template so the data can be shared and interpreted correctly. That template is called a Schema. Schemas are the general structure of the credential. In our example, they tell us what information must be included on the driver's license in order for it to be valid, like Full name, Address, Eye color, etc. In short, they are the attributes that you want to include in this credential.","title":"Schema"},{"location":"learn/credentials/#verifications","text":"Passes are documents generated from credentials that contain only the information required to be verified. They can be generated in advance or in real-time. Passes minimize the information about you that is shared with third parties. Credentials are signed using BLS keys. These create from the credential fields.","title":"Verifications"},{"location":"learn/ecosystems/","text":"Ecosystems \u00b6 Exchanging credentials often requires many different participants to all communicate and collaborate. Aligning standards and incentives is challenging. We've made it simple to create an ecosystem of participants to all exchange credentials. Potential Scenarios \u00b6 Industry groups, enterprises, and startups who are deploying this technology to multi-party ecosystems. Our focus on building for interoperability, hyper-scalability, and ease of use means you can get to market faster with a better product with Trinsic than any other way. Trust ecosystems are networks of participants that can authenticate to and share data with one another. Trust ecosystems exist all around us, but most are analog and disaggregated. The first trust ecosystems to go digital were payments networks. Visa, MasterCard, etc. introduced a standard mechanism to allow consumers to make purchases with any merchant using credit from any bank. Visa created an enduring business while simultaneously unlocking value for all participants involved. Credit card networks represent only one kind of trust ecosystem. A trust ecosystem at a minimum has the following 4 roles. Provider - provides the tools and rules to the rest of the participants to ensure a healthy ecosystem, generally through a product experience that is sold to the other participants Issuer - is the source of data that is shared throughout an ecosystem Verifier - consumes data in an ecosystem Holder - holds data, and is generally the subject of the data, in an ecosystem Anatomy of a Trust Ecosystem \u00b6 Before diving into the value provided by each participant, it\u2019s helpful to cover how it works at a high level. You may dive deeper into any of these items by clicking into the respective pages. We\u2019ll use the analogy of a payment network to conceptualize the purpose of each component. Wallet - A place to securely store verifiable credentials. Credential - W3C Verifiable Credentials that contain valuable data about a subject. These are signed and issued by an issuer. Pass - A presentation of a verifiable credential that only includes the information required for use case. Underlying Tech - All of the additional standardized technology Trinsic uses to build trust ecosystems. Value of Trust Ecosystems to Participants \u00b6 The first step to successfully building a trust ecosystem that can scale is to identify the value for each of the participants. Here we will elaborate on the value derived by each actor in an ecosystem and how Trinsic\u2019s platform is optimized to help deliver it. Providers \u00b6 Providers typically already have, or are building, a product or platform to sell to the issuers and verifiers with the goal of creating a sustainable business. Visa, for example, isn\u2019t a currency, a bank, or a merchant. They sell the rails for transaction settlement to banks and merchants to enable the seamless transactions we all enjoy. By taking a small interchange fee, they capture value alongside the banks and merchants and have built a sustainable business. Trinsic is the only company to offer a product tailored specifically for providers. That means instead of patching together various open source components meant for issuers or verifiers, Trinsic offers a product built from the ground-up to accommodate the unique needs of providers. Ultimately, that means providers using Trinsic get to market faster with better products. Issuers \u00b6 Issuers realize value when they extend or augment their existing business operations. By issuing the data they already have in verifiable credential form, they often can increase revenue, reduce verification costs, and improve brand presence. When credit cards were in their infancy, banks began issuing cards because it allowed them to continue their existing business (giving credit) in a new way. Likewise, the issuers that get the most value from verifiable credentials are ones who already have data about people, and simply need to give it to them in a new way (e.g. medical labs who already give paper documents can now give digital form). Trinsic\u2019s platform is optimized to both reduce onboarding costs and add help issuers scale without increasing their costs Before credit cards banks could offer various consumer loans Holders \u00b6 Holders acquire the most convenient way to prove something about themselves digitally, both in-person and online Before credit cards, consumers needed to pay with paper. Paying with credit meant bespoke processes with each individual retailer (e.g. opening a tab at a bar, creating a Macy\u2019s account, etc). Likewise today our digital identities are all siloed and separate, resulting in a myriad of problems for consumers. Verifiers \u00b6 Verifiers get instant, trusted authentication and verification without needing to maintain their own infrastructure Before credit card networks like Visa, merchants needed to issue credit and manage collections in-house if they wanted customers who could buy on credit. Likewise, companies in virtually every industry have compliance, risk, and identity departments where they manage this in-house. Just as Visa turned electronic payments into a simple terminal installation for merchants, so too will trust ecosystems unlock the ability for verifiers of all kinds to focus on their true business without compromising on trust and security. Like the internet itself, trust over IP represents a massive business opportunity for innovators in all industries. And like the internet itself, the vast majority of the value will be created at the application layer.","title":"Identity Ecosystems"},{"location":"learn/ecosystems/#ecosystems","text":"Exchanging credentials often requires many different participants to all communicate and collaborate. Aligning standards and incentives is challenging. We've made it simple to create an ecosystem of participants to all exchange credentials.","title":"Ecosystems"},{"location":"learn/ecosystems/#potential-scenarios","text":"Industry groups, enterprises, and startups who are deploying this technology to multi-party ecosystems. Our focus on building for interoperability, hyper-scalability, and ease of use means you can get to market faster with a better product with Trinsic than any other way. Trust ecosystems are networks of participants that can authenticate to and share data with one another. Trust ecosystems exist all around us, but most are analog and disaggregated. The first trust ecosystems to go digital were payments networks. Visa, MasterCard, etc. introduced a standard mechanism to allow consumers to make purchases with any merchant using credit from any bank. Visa created an enduring business while simultaneously unlocking value for all participants involved. Credit card networks represent only one kind of trust ecosystem. A trust ecosystem at a minimum has the following 4 roles. Provider - provides the tools and rules to the rest of the participants to ensure a healthy ecosystem, generally through a product experience that is sold to the other participants Issuer - is the source of data that is shared throughout an ecosystem Verifier - consumes data in an ecosystem Holder - holds data, and is generally the subject of the data, in an ecosystem","title":"Potential Scenarios"},{"location":"learn/ecosystems/#anatomy-of-a-trust-ecosystem","text":"Before diving into the value provided by each participant, it\u2019s helpful to cover how it works at a high level. You may dive deeper into any of these items by clicking into the respective pages. We\u2019ll use the analogy of a payment network to conceptualize the purpose of each component. Wallet - A place to securely store verifiable credentials. Credential - W3C Verifiable Credentials that contain valuable data about a subject. These are signed and issued by an issuer. Pass - A presentation of a verifiable credential that only includes the information required for use case. Underlying Tech - All of the additional standardized technology Trinsic uses to build trust ecosystems.","title":"Anatomy of a Trust Ecosystem"},{"location":"learn/ecosystems/#value-of-trust-ecosystems-to-participants","text":"The first step to successfully building a trust ecosystem that can scale is to identify the value for each of the participants. Here we will elaborate on the value derived by each actor in an ecosystem and how Trinsic\u2019s platform is optimized to help deliver it.","title":"Value of Trust Ecosystems to Participants"},{"location":"learn/ecosystems/#providers","text":"Providers typically already have, or are building, a product or platform to sell to the issuers and verifiers with the goal of creating a sustainable business. Visa, for example, isn\u2019t a currency, a bank, or a merchant. They sell the rails for transaction settlement to banks and merchants to enable the seamless transactions we all enjoy. By taking a small interchange fee, they capture value alongside the banks and merchants and have built a sustainable business. Trinsic is the only company to offer a product tailored specifically for providers. That means instead of patching together various open source components meant for issuers or verifiers, Trinsic offers a product built from the ground-up to accommodate the unique needs of providers. Ultimately, that means providers using Trinsic get to market faster with better products.","title":"Providers"},{"location":"learn/ecosystems/#issuers","text":"Issuers realize value when they extend or augment their existing business operations. By issuing the data they already have in verifiable credential form, they often can increase revenue, reduce verification costs, and improve brand presence. When credit cards were in their infancy, banks began issuing cards because it allowed them to continue their existing business (giving credit) in a new way. Likewise, the issuers that get the most value from verifiable credentials are ones who already have data about people, and simply need to give it to them in a new way (e.g. medical labs who already give paper documents can now give digital form). Trinsic\u2019s platform is optimized to both reduce onboarding costs and add help issuers scale without increasing their costs Before credit cards banks could offer various consumer loans","title":"Issuers"},{"location":"learn/ecosystems/#holders","text":"Holders acquire the most convenient way to prove something about themselves digitally, both in-person and online Before credit cards, consumers needed to pay with paper. Paying with credit meant bespoke processes with each individual retailer (e.g. opening a tab at a bar, creating a Macy\u2019s account, etc). Likewise today our digital identities are all siloed and separate, resulting in a myriad of problems for consumers.","title":"Holders"},{"location":"learn/ecosystems/#verifiers","text":"Verifiers get instant, trusted authentication and verification without needing to maintain their own infrastructure Before credit card networks like Visa, merchants needed to issue credit and manage collections in-house if they wanted customers who could buy on credit. Likewise, companies in virtually every industry have compliance, risk, and identity departments where they manage this in-house. Just as Visa turned electronic payments into a simple terminal installation for merchants, so too will trust ecosystems unlock the ability for verifiers of all kinds to focus on their true business without compromising on trust and security. Like the internet itself, trust over IP represents a massive business opportunity for innovators in all industries. And like the internet itself, the vast majority of the value will be created at the application layer.","title":"Verifiers"},{"location":"learn/intro/","text":"What is Trinsic? \u00b6 Trinsic is a hosting provider for identity wallets and an SDK for developers that want to interact with them. You can use Trinsic to give your end-users identity wallets and then share, store, and verify data through them. Wallets \u00b6 Identity Wallets are secure, partitioned data stores for information that needs to get verified. This normally is a person, but it can also be an organization or a device. You can use Trinsic's platform to invite end-users to create a cloud-hosted identity wallet that can be accessed on any device using multi-factor passwordless authentication. Once created, applications and organizations can issue data to the identity wallet. Other applications can request to verify information from the wallet. If the end-user accepts the request, a proof of the requested information will be created and sent to the requester. Using identity wallets, you can build powerful products that preserve your end-user's privacy without compromising on convenience. Wallet Service Credentials & Proofs \u00b6 Trinsic's wallets are built to represent verifiable data as credentials. This allows any information sent to the identity wallet to be easily verified using interoperable standards. Because we follow a standardized open data model, identity wallets can bridge software platforms, letting individuals use their data wherever they choose. To minimize the amount of information that is requested from identity wallets, a credential's attributes can be filtered to generate a proof of the credential with only the data required to fulfill a verifier's request. Credential Service Templates \u00b6 Credential templates let you publish a credential format for other's to follow. There are often more than one issuer of the same type of credential, and this allows issuers to reuse the same credential format and share the same attribute types. When data models can be reused, more interoperability can be achieved between different systems. This let's data that previously had to be manually entered via form or sent via custom API integration get automatically exchanged and verified without needing human interaction. Template Service Trust Registries \u00b6 A trust registry is a way for a wallet to publish a list of other wallets that it trusts to issue and verifier credentials. This is useful when building trust without a centralized service or database. If you onboard wallets, it is likely that the wallet holders already have a connection with you. You can publish a list of issuers and verifiers that you've also vetted and onboarded and the wallet holders can reference this list before receiving or sharing their information with another wallet. When verifying a credential, a verifier can cross-reference the issuer's identifier within the credential with a trust registry to ensure it was actually issued by an organization that they trust. Trust Registry Service Ecosystems \u00b6 When creating a product that uses identity wallets, it is useful to have the tools to onboard participants that want to either issue, store, or verify credentials. Trinsic Ecosystems is a set of tools built so you can invite participants to an ecosystem and configure their wallets for them. This makes it possible to quickly go live with a proof of concept or pilot without requiring your ecosystem participants to do any setup or integrations themselves. Provider Service Open Standards \u00b6 Trinsic's technology is all based on open web standards. Our goal is to promote a future of applications where identity and personal data is independent from applications. To meet this end, we use decentralized identifiers that can be generated and resolved without needing a centralized database. We also follow the data model for verifiable credentials so that data sent by one application can be presented at another without requiring a specific vendor. Learn More Security and Privacy \u00b6 As a hosting provider of identity wallets, we've recognized the need for strong security and privacy since before we started building. Our identity wallets are secured using zero knowledge authentication. No private keys are stored or processed on our servers. They are all generated locally by our SDKs. We do this using a lightweight zero-knowledge proof protocol. Even if an adversary were to intercept a payload, they would not be able to reuse the token to gain additional access to our system. Learn More","title":"What is Trinsic?"},{"location":"learn/intro/#what-is-trinsic","text":"Trinsic is a hosting provider for identity wallets and an SDK for developers that want to interact with them. You can use Trinsic to give your end-users identity wallets and then share, store, and verify data through them.","title":"What is Trinsic?"},{"location":"learn/intro/#wallets","text":"Identity Wallets are secure, partitioned data stores for information that needs to get verified. This normally is a person, but it can also be an organization or a device. You can use Trinsic's platform to invite end-users to create a cloud-hosted identity wallet that can be accessed on any device using multi-factor passwordless authentication. Once created, applications and organizations can issue data to the identity wallet. Other applications can request to verify information from the wallet. If the end-user accepts the request, a proof of the requested information will be created and sent to the requester. Using identity wallets, you can build powerful products that preserve your end-user's privacy without compromising on convenience. Wallet Service","title":"Wallets"},{"location":"learn/intro/#credentials-proofs","text":"Trinsic's wallets are built to represent verifiable data as credentials. This allows any information sent to the identity wallet to be easily verified using interoperable standards. Because we follow a standardized open data model, identity wallets can bridge software platforms, letting individuals use their data wherever they choose. To minimize the amount of information that is requested from identity wallets, a credential's attributes can be filtered to generate a proof of the credential with only the data required to fulfill a verifier's request. Credential Service","title":"Credentials &amp; Proofs"},{"location":"learn/intro/#templates","text":"Credential templates let you publish a credential format for other's to follow. There are often more than one issuer of the same type of credential, and this allows issuers to reuse the same credential format and share the same attribute types. When data models can be reused, more interoperability can be achieved between different systems. This let's data that previously had to be manually entered via form or sent via custom API integration get automatically exchanged and verified without needing human interaction. Template Service","title":"Templates"},{"location":"learn/intro/#trust-registries","text":"A trust registry is a way for a wallet to publish a list of other wallets that it trusts to issue and verifier credentials. This is useful when building trust without a centralized service or database. If you onboard wallets, it is likely that the wallet holders already have a connection with you. You can publish a list of issuers and verifiers that you've also vetted and onboarded and the wallet holders can reference this list before receiving or sharing their information with another wallet. When verifying a credential, a verifier can cross-reference the issuer's identifier within the credential with a trust registry to ensure it was actually issued by an organization that they trust. Trust Registry Service","title":"Trust Registries"},{"location":"learn/intro/#ecosystems","text":"When creating a product that uses identity wallets, it is useful to have the tools to onboard participants that want to either issue, store, or verify credentials. Trinsic Ecosystems is a set of tools built so you can invite participants to an ecosystem and configure their wallets for them. This makes it possible to quickly go live with a proof of concept or pilot without requiring your ecosystem participants to do any setup or integrations themselves. Provider Service","title":"Ecosystems"},{"location":"learn/intro/#open-standards","text":"Trinsic's technology is all based on open web standards. Our goal is to promote a future of applications where identity and personal data is independent from applications. To meet this end, we use decentralized identifiers that can be generated and resolved without needing a centralized database. We also follow the data model for verifiable credentials so that data sent by one application can be presented at another without requiring a specific vendor. Learn More","title":"Open Standards"},{"location":"learn/intro/#security-and-privacy","text":"As a hosting provider of identity wallets, we've recognized the need for strong security and privacy since before we started building. Our identity wallets are secured using zero knowledge authentication. No private keys are stored or processed on our servers. They are all generated locally by our SDKs. We do this using a lightweight zero-knowledge proof protocol. Even if an adversary were to intercept a payload, they would not be able to reuse the token to gain additional access to our system. Learn More","title":"Security and Privacy"},{"location":"learn/security/","text":"Security Infrastructure \u00b6 Overview \u00b6 Our cloud services are secured using a novel method of authentication based on zero-knowledge proofs . This approach allows us to introduce passwordless client authentication with improved security and user experience. Compared to traditional security methods that store users' credentials on the server, our approach relies on a one-time client/server negotiation without storing any user secrets on our servers. All secrets are stored with the user client and are entirely in their control. During authentication, users present proof of knowledge of these secret tokens, instead of the actual tokens. This proof is generated with each request and is unique for that request only. Zero-knowledge Architecture \u00b6 TODO: Comparison to traditional security models Oberon Auth Scheme \u00b6 A succinct ZKP protocol for authentication. It works by using techniques similar to Identity-Based/Attribute-Based signatures. Oberon allows endpoints to issue multi-factor capable tokens to consumers who can prove their validity without disclosing the tokens themselves and without requiring email, SMS, or authenticator apps. Endpoints only need to store a single public key and not any tokens. An attacker that breaks into the server doesn't have any password/token files to steal and only would see a public key. The proof of token validity is only 256 bytes while the token itself is only 48 bytes. The issuing party and verifying servers can be separate entities. Crypto details for Oberon Account Registration \u00b6 The below diagram illustrates how client and server interact during the registration process and negotiate the data for authentication: sequenceDiagram actor Client Client->>Server: Register new account or ecosystem Server-->>Client: Generated token Note right of Server: Does not store token opt Note over Client: Apply multi-factor security<br />using PIN, word phrase, HSM, etc.<br />by cryptographically blinding<br/>the secret token Client->>Client: Token protection end Client->>Client: Save token on client device API Requests \u00b6 The process of making authenticated API requests against the server involves generating a proof of knowledge and appending it to the request headers. This proof is: valid for a limited time only (order of milliseconds) unique and cannot be used twice (replay protection) bound to the current request payload (mitm protection) The diagram below illustrates the steps involved in generating proof and interacting with the server. sequenceDiagram actor U as Client participant A as Server U->>U: Read Token U->>U: Generate proof of token U->>A: Make API Request note right of U: Proof is added in 'Authorization' header A->>A: Check authorization alt sucesss A->>A: Process request A-->>U: Send response else invalid proof A-->>U: 401 Unauthorized end","title":"Security Overview"},{"location":"learn/security/#security-infrastructure","text":"","title":"Security Infrastructure"},{"location":"learn/security/#overview","text":"Our cloud services are secured using a novel method of authentication based on zero-knowledge proofs . This approach allows us to introduce passwordless client authentication with improved security and user experience. Compared to traditional security methods that store users' credentials on the server, our approach relies on a one-time client/server negotiation without storing any user secrets on our servers. All secrets are stored with the user client and are entirely in their control. During authentication, users present proof of knowledge of these secret tokens, instead of the actual tokens. This proof is generated with each request and is unique for that request only.","title":"Overview"},{"location":"learn/security/#zero-knowledge-architecture","text":"TODO: Comparison to traditional security models","title":"Zero-knowledge Architecture"},{"location":"learn/security/#oberon-auth-scheme","text":"A succinct ZKP protocol for authentication. It works by using techniques similar to Identity-Based/Attribute-Based signatures. Oberon allows endpoints to issue multi-factor capable tokens to consumers who can prove their validity without disclosing the tokens themselves and without requiring email, SMS, or authenticator apps. Endpoints only need to store a single public key and not any tokens. An attacker that breaks into the server doesn't have any password/token files to steal and only would see a public key. The proof of token validity is only 256 bytes while the token itself is only 48 bytes. The issuing party and verifying servers can be separate entities. Crypto details for Oberon","title":"Oberon Auth Scheme"},{"location":"learn/security/#account-registration","text":"The below diagram illustrates how client and server interact during the registration process and negotiate the data for authentication: sequenceDiagram actor Client Client->>Server: Register new account or ecosystem Server-->>Client: Generated token Note right of Server: Does not store token opt Note over Client: Apply multi-factor security<br />using PIN, word phrase, HSM, etc.<br />by cryptographically blinding<br/>the secret token Client->>Client: Token protection end Client->>Client: Save token on client device","title":"Account Registration"},{"location":"learn/security/#api-requests","text":"The process of making authenticated API requests against the server involves generating a proof of knowledge and appending it to the request headers. This proof is: valid for a limited time only (order of milliseconds) unique and cannot be used twice (replay protection) bound to the current request payload (mitm protection) The diagram below illustrates the steps involved in generating proof and interacting with the server. sequenceDiagram actor U as Client participant A as Server U->>U: Read Token U->>U: Generate proof of token U->>A: Make API Request note right of U: Proof is added in 'Authorization' header A->>A: Check authorization alt sucesss A->>A: Process request A-->>U: Send response else invalid proof A-->>U: 401 Unauthorized end","title":"API Requests"},{"location":"learn/standards/","text":"Underlying Tech \u00b6 Linked Data \u00b6 When we consider credentials getting exchanged online far and wide, a problem starts to occur - how does everyone know what every else means when they show a credential? To the rescue comes Linked Data, a format for representing structured data with self-contained descriptors of that data. \"Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files\" - W3C Wiki on Linked Data Decentralized Identifiers \u00b6 Taken from the Verifiable Credential Data Model , a decentralized identifier is \"a portable URL-based identifier, also known as a DID, associated with an entity. These identifiers are most often used in a verifiable credential and are associated with subjects such that a verifiable credential itself can be easily ported from one repository to another without the need to reissue the credential. An example of a DID is did:example:123456abcdef \" Zero Knowledge Proofs \u00b6 One of the most exciting qualities of verifiable credentials are their ability to minimize the data shared about you when you prove who you are. The classic example is showing your driver's license in a bar. While a human bouncer may forget all the revealing information on your driver's license, a computerized bouncer that scans your driver's license never forgets any information. With zero knowledge proofs, you can choose specific information from your credentials to share with verifiers. These are enabled through a BBS+ Signature specification .","title":"Standards"},{"location":"learn/standards/#underlying-tech","text":"","title":"Underlying Tech"},{"location":"learn/standards/#linked-data","text":"When we consider credentials getting exchanged online far and wide, a problem starts to occur - how does everyone know what every else means when they show a credential? To the rescue comes Linked Data, a format for representing structured data with self-contained descriptors of that data. \"Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files\" - W3C Wiki on Linked Data","title":"Linked Data"},{"location":"learn/standards/#decentralized-identifiers","text":"Taken from the Verifiable Credential Data Model , a decentralized identifier is \"a portable URL-based identifier, also known as a DID, associated with an entity. These identifiers are most often used in a verifiable credential and are associated with subjects such that a verifiable credential itself can be easily ported from one repository to another without the need to reissue the credential. An example of a DID is did:example:123456abcdef \"","title":"Decentralized Identifiers"},{"location":"learn/standards/#zero-knowledge-proofs","text":"One of the most exciting qualities of verifiable credentials are their ability to minimize the data shared about you when you prove who you are. The classic example is showing your driver's license in a bar. While a human bouncer may forget all the revealing information on your driver's license, a computerized bouncer that scans your driver's license never forgets any information. With zero knowledge proofs, you can choose specific information from your credentials to share with verifiers. These are enabled through a BBS+ Signature specification .","title":"Zero Knowledge Proofs"},{"location":"learn/templates/","text":"Credential Templates \u00b6 Trinsic's credential templates make it easy to define types of credentials and publish these types for multiple issuers all to use. Credential templates will create two things to include in a credential: a json schema and a json ld context. Templates remove all of that complexity and let you define a list of attributes along with the attribute types and descriptions. This an example of a list of attributes that would comprise a credential template: { \"name\": { \"type\": \"string\", \"description\": \"Name of the business\", }, \"website\": { \"type\": \"string\", \"description\": \"More information about the business\" }, \"rating\":{ \"type\": \"number\", \"description\": \"rating on scale of 1-10\", \"optional\": false }, \"details\":{ \"type\": \"string\", \"description\": \"An individual's last name\", \"optional\": false } } This will create a Template that has the following structure: TemplateData { id: \"urn:template:alices-local-guides:review\", name: \"Review\", version: 1, fields: { \"name\": TemplateField { description: \"Name of the business\", optional: false, r#type: String, }, \"rating\": TemplateField { description: \"rating on scale of 1-10\", optional: false, r#type: Number, }, \"details\": TemplateField { description: \"An individual's last name\", optional: false, r#type: String, }, \"website\": TemplateField { description: \"More information about the business\", optional: false, r#type: String, }, }, allow_additional_fields: true, schema_uri: \"https://staging-schema.trinsic.cloud/__default/review\", context_uri: \"https://staging-schema.trinsic.cloud/__default/review/context\", ecosystem_id: \"__default\", r#type: \"VerifiableCredential\", } You can view the schema_uri and the context_uri in the browser as raw json","title":"Templates"},{"location":"learn/templates/#credential-templates","text":"Trinsic's credential templates make it easy to define types of credentials and publish these types for multiple issuers all to use. Credential templates will create two things to include in a credential: a json schema and a json ld context. Templates remove all of that complexity and let you define a list of attributes along with the attribute types and descriptions. This an example of a list of attributes that would comprise a credential template: { \"name\": { \"type\": \"string\", \"description\": \"Name of the business\", }, \"website\": { \"type\": \"string\", \"description\": \"More information about the business\" }, \"rating\":{ \"type\": \"number\", \"description\": \"rating on scale of 1-10\", \"optional\": false }, \"details\":{ \"type\": \"string\", \"description\": \"An individual's last name\", \"optional\": false } } This will create a Template that has the following structure: TemplateData { id: \"urn:template:alices-local-guides:review\", name: \"Review\", version: 1, fields: { \"name\": TemplateField { description: \"Name of the business\", optional: false, r#type: String, }, \"rating\": TemplateField { description: \"rating on scale of 1-10\", optional: false, r#type: Number, }, \"details\": TemplateField { description: \"An individual's last name\", optional: false, r#type: String, }, \"website\": TemplateField { description: \"More information about the business\", optional: false, r#type: String, }, }, allow_additional_fields: true, schema_uri: \"https://staging-schema.trinsic.cloud/__default/review\", context_uri: \"https://staging-schema.trinsic.cloud/__default/review/context\", ecosystem_id: \"__default\", r#type: \"VerifiableCredential\", } You can view the schema_uri and the context_uri in the browser as raw json","title":"Credential Templates"},{"location":"learn/wallets/","text":"Wallets \u00b6 What are wallets? \u00b6 A wallet is a secure place to store credentials. You can create a wallet using the Trinsic CLI or SDK and begin using it to store and share credentials. Wallet storage is scoped to a single person or subject. Each wallet has the capability to store and share credentials and proofs proofs. A provider wallet can also define templates, create an ecosystem governance framework, and invite wallets to their ecosystem. Data wallets are meant to help individuals manage their digital credentials and cryptographic keys. How to use wallets in your app \u00b6 Instead of users creating accounts when they sign up for your app, users can instead connect their wallet. Because many users will be first-time wallet holders, if a user is signing up for your app and they don't have a wallet, we make it easy to create new wallets for your users with the invite command. Once you've invited a user to a wallet, they can enter the 2fa code to log in. You can give each of your end-users a wallet tied to their email address or phone number. Wallet Architecture \u00b6 While wallets are hosted on a server and your client application with connect with the wallet, the wallets communicate are peer to peer. Wallets can be thought of a little like an email inbox. Each wallet can only be accessed by a set of keys stored on devices. Commands \u00b6 Store Item Search Send","title":"Wallets"},{"location":"learn/wallets/#wallets","text":"","title":"Wallets"},{"location":"learn/wallets/#what-are-wallets","text":"A wallet is a secure place to store credentials. You can create a wallet using the Trinsic CLI or SDK and begin using it to store and share credentials. Wallet storage is scoped to a single person or subject. Each wallet has the capability to store and share credentials and proofs proofs. A provider wallet can also define templates, create an ecosystem governance framework, and invite wallets to their ecosystem. Data wallets are meant to help individuals manage their digital credentials and cryptographic keys.","title":"What are wallets?"},{"location":"learn/wallets/#how-to-use-wallets-in-your-app","text":"Instead of users creating accounts when they sign up for your app, users can instead connect their wallet. Because many users will be first-time wallet holders, if a user is signing up for your app and they don't have a wallet, we make it easy to create new wallets for your users with the invite command. Once you've invited a user to a wallet, they can enter the 2fa code to log in. You can give each of your end-users a wallet tied to their email address or phone number.","title":"How to use wallets in your app"},{"location":"learn/wallets/#wallet-architecture","text":"While wallets are hosted on a server and your client application with connect with the wallet, the wallets communicate are peer to peer. Wallets can be thought of a little like an email inbox. Each wallet can only be accessed by a set of keys stored on devices.","title":"Wallet Architecture"},{"location":"learn/wallets/#commands","text":"Store Item Search Send","title":"Commands"},{"location":"node/","text":"The Trinsic Javascript / Node SDK \u00b6 The Trinsic Node SDK makes it easy to interact with the Trinsic API from any backend javascript application. The most recent version of the library can be found on npm. You can find the SDKs source on Github . Installation \u00b6 Install the package for Node from npmjs.com Install npm i @trinsic/trinsic Next Steps \u00b6 Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference. Start Walkthrough Explore API","title":"Node"},{"location":"node/#the-trinsic-javascript-node-sdk","text":"The Trinsic Node SDK makes it easy to interact with the Trinsic API from any backend javascript application. The most recent version of the library can be found on npm. You can find the SDKs source on Github .","title":"The Trinsic Javascript / Node SDK"},{"location":"node/#installation","text":"Install the package for Node from npmjs.com Install npm i @trinsic/trinsic","title":"Installation"},{"location":"node/#next-steps","text":"Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference. Start Walkthrough Explore API","title":"Next Steps"},{"location":"python/","text":"The Trinsic Python SDK \u00b6 The Trinsic Python SDK makes it easy to interact with the Trinsic API from any Python application. The most recent version of the library can be found on PyPi. You can find the SDKs source on Github . Installation and Configuration \u00b6 Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here If you install to a different location for debugging, use the environment variable LD_LIBRARY_PATH , even on Windows. Recommended: Create a virtual environment Install the trinsic package pip install trinsic-sdk Test installation by running the following python script: import asyncio from trinsic.services import AccountService async def demo (): account_service = AccountService () profile = await account_service . sign_in () print ( profile ) account_service . close () if __name__ == \"__main__\" : asyncio . run ( demo ()) The output should look something like this: AccountProfile ( profile_type = 'https://trinsic.id/security/v1/oberon' , auth_data = b '\\n*urn:trinsic:wallets:JkhchLXS8NDwTjmJjNogkQ\\x12$1d58106c-325a-4f45-abe0-6a14aa613a10' , auth_token = b '\\x83E\\x06p\\xd60V\\xe0D\\x12NU\\xe7\\n6\\x06\\x19 \\x0b\\xe0\\x8er\\xf2\\xc1\\xb3\\x96\\xdb\\xbd/\\xf5#\\xa7\\xe7F\\x10\\x97E\\xe2\\xa9\\xc4\\x10\\xdfJ\\xbe\\xea\\xa3Fz' , protection = TokenProtection ()) Next Steps \u00b6 Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API Python API Reference","title":"Python"},{"location":"python/#the-trinsic-python-sdk","text":"The Trinsic Python SDK makes it easy to interact with the Trinsic API from any Python application. The most recent version of the library can be found on PyPi. You can find the SDKs source on Github .","title":"The Trinsic Python SDK"},{"location":"python/#installation-and-configuration","text":"Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here If you install to a different location for debugging, use the environment variable LD_LIBRARY_PATH , even on Windows. Recommended: Create a virtual environment Install the trinsic package pip install trinsic-sdk Test installation by running the following python script: import asyncio from trinsic.services import AccountService async def demo (): account_service = AccountService () profile = await account_service . sign_in () print ( profile ) account_service . close () if __name__ == \"__main__\" : asyncio . run ( demo ()) The output should look something like this: AccountProfile ( profile_type = 'https://trinsic.id/security/v1/oberon' , auth_data = b '\\n*urn:trinsic:wallets:JkhchLXS8NDwTjmJjNogkQ\\x12$1d58106c-325a-4f45-abe0-6a14aa613a10' , auth_token = b '\\x83E\\x06p\\xd60V\\xe0D\\x12NU\\xe7\\n6\\x06\\x19 \\x0b\\xe0\\x8er\\xf2\\xc1\\xb3\\x96\\xdb\\xbd/\\xf5#\\xa7\\xe7F\\x10\\x97E\\xe2\\xa9\\xc4\\x10\\xdfJ\\xbe\\xea\\xa3Fz' , protection = TokenProtection ())","title":"Installation and Configuration"},{"location":"python/#next-steps","text":"Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API Python API Reference","title":"Next Steps"},{"location":"reference/","text":"Overview \u00b6 If you are ready to begin integrating the SDK, make sure you have an SDK installed and configured. You can install each SDK by following the instructions in each page under Build in the sidebar. When using the SDK, you can pass parameters to the default service constructors and use the provided methods to set different active profiles. Authorization \u00b6 See our security section for more information on how we have implemented wallet authentication and authorization. SDK Services \u00b6 Our SDK is broken down into the following services: Account Service Wallet Service Credential Service Trust Registry Service Template Service Provider Service","title":"Overview"},{"location":"reference/#overview","text":"If you are ready to begin integrating the SDK, make sure you have an SDK installed and configured. You can install each SDK by following the instructions in each page under Build in the sidebar. When using the SDK, you can pass parameters to the default service constructors and use the provided methods to set different active profiles.","title":"Overview"},{"location":"reference/#authorization","text":"See our security section for more information on how we have implemented wallet authentication and authorization.","title":"Authorization"},{"location":"reference/#sdk-services","text":"Our SDK is broken down into the following services: Account Service Wallet Service Credential Service Trust Registry Service Template Service Provider Service","title":"SDK Services"},{"location":"reference/proto/","text":"Protocol Documentation \u00b6 Table of Contents \u00b6 pbmse/v1/pbmse.proto EncryptedMessage EncryptionHeader EncryptionRecipient Signature SignatureHeader SignedMessage EncryptionAlgorithm EncryptionMode sdk/options/v1/options.proto ServiceOptions services/account/v1/account.proto AccountDetails AccountEcosystem AccountProfile InfoRequest InfoResponse ListDevicesRequest ListDevicesResponse RevokeDeviceRequest RevokeDeviceResponse SignInRequest SignInResponse TokenProtection ConfirmationMethod Account services/common/v1/common.proto Nonce ServerConfig ResponseStatus Common services/debug/v1/debug.proto Debugging services/provider/v1/provider.proto CreateEcosystemRequest CreateEcosystemResponse Ecosystem GenerateTokenRequest GenerateTokenResponse InvitationStatusRequest InvitationStatusResponse Invite InviteRequest InviteRequest.DidCommInvitation InviteResponse InvitationStatusResponse.Status ParticipantType Provider services/trust-registry/v1/trust-registry.proto AddFrameworkRequest AddFrameworkResponse CheckIssuerStatusRequest CheckIssuerStatusResponse CheckVerifierStatusRequest CheckVerifierStatusResponse FetchDataRequest FetchDataResponse GovernanceFramework RegisterIssuerRequest RegisterIssuerResponse RegisterVerifierRequest RegisterVerifierResponse RemoveFrameworkRequest RemoveFrameworkResponse SearchRegistryRequest SearchRegistryResponse UnregisterIssuerRequest UnregisterIssuerResponse UnregisterVerifierRequest UnregisterVerifierResponse RegistrationStatus TrustRegistry services/universal-wallet/v1/universal-wallet.proto DeleteItemRequest DeleteItemResponse GetItemRequest GetItemResponse InsertItemRequest InsertItemResponse SearchRequest SearchResponse UpdateItemRequest UpdateItemResponse UniversalWallet services/verifiable-credentials/templates/v1/templates.proto CreateCredentialTemplateRequest CreateCredentialTemplateRequest.FieldsEntry CreateCredentialTemplateResponse DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse GetCredentialTemplateRequest GetCredentialTemplateResponse GetTemplateRequest GetTemplateResponse ListCredentialTemplatesRequest ListCredentialTemplatesResponse ListTemplatesRequest ListTemplatesResponse SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse TemplateData TemplateData.FieldsEntry TemplateField FieldType CredentialTemplates services/verifiable-credentials/v1/verifiable-credentials.proto CheckStatusRequest CheckStatusResponse CreateProofRequest CreateProofResponse IssueFromTemplateRequest IssueFromTemplateResponse IssueRequest IssueResponse SendRequest SendResponse UpdateStatusRequest UpdateStatusResponse VerifyProofRequest VerifyProofResponse VerifiableCredential Scalar Value Types Top pbmse/v1/pbmse.proto \u00b6 EncryptedMessage \u00b6 Field Type Label Description iv bytes aad bytes ciphertext bytes tag bytes recipients EncryptionRecipient repeated EncryptionHeader \u00b6 Field Type Label Description mode EncryptionMode algorithm EncryptionAlgorithm key_id string sender_key_id string EncryptionRecipient \u00b6 Field Type Label Description header EncryptionHeader content_encryption_key bytes Signature \u00b6 Field Type Label Description header bytes signature bytes SignatureHeader \u00b6 Field Type Label Description algorithm string key_id string SignedMessage \u00b6 JWS Protocol buffer message signing and encryption Field Type Label Description payload bytes signatures Signature repeated EncryptionAlgorithm \u00b6 Name Number Description ENCRYPTION_ALGORITHM_UNSPECIFIED 0 ENCRYPTION_ALGORITHM_XCHACHA20POLY1305 1 ENCRYPTION_ALGORITHM_AES_GCM 2 EncryptionMode \u00b6 Name Number Description ENCRYPTION_MODE_UNSPECIFIED 0 ENCRYPTION_MODE_DIRECT 1 ENCRYPTION_MODE_CONTENT_ENCRYPTION_KEY 2 Top sdk/options/v1/options.proto \u00b6 ServiceOptions \u00b6 service options Field Type Label Description server_endpoint string service endpoint server_port int32 service port server_use_tls bool indicates if tls is used auth_token string default auth token for oberon security scheme default_ecosystem string ecosystem to use with endpoints that require it Top services/account/v1/account.proto \u00b6 AccountDetails \u00b6 Account Registration Details Field Type Label Description name string Account name (optional) email string Email account (required) sms string SMS number including country code (optional) AccountEcosystem \u00b6 Field Type Label Description id string name string description string uri string AccountProfile \u00b6 Device profile containing sensitive authentication data. This information should be stored securely Field Type Label Description profile_type string The type of profile, used to differentiate between protocol schemes or versions auth_data bytes Auth data containg information about the current device access auth_token bytes Secure token issued by server used to generate zero-knowledge proofs protection TokenProtection Token security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication. InfoRequest \u00b6 InfoResponse \u00b6 Field Type Label Description details AccountDetails The account details associated with the calling request context ecosystems AccountEcosystem repeated any ecosystems the account has access to ListDevicesRequest \u00b6 ListDevicesResponse \u00b6 RevokeDeviceRequest \u00b6 RevokeDeviceResponse \u00b6 SignInRequest \u00b6 Request for creating new account Field Type Label Description details AccountDetails Account registration details invitation_code string Invitation code associated with this registration This field is optional. ecosystem_id string EcosystemId to sign in. This field is optional and will be ignored if invitation_code is passed SignInResponse \u00b6 Response for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc. Field Type Label Description status services.common.v1.ResponseStatus The status of the response confirmation_method ConfirmationMethod Indicates if confirmation of account is required. This settings is configured globally by the server administrator. profile AccountProfile Contains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data. TokenProtection \u00b6 Token protection info Field Type Label Description enabled bool Indicates if token is protected using a PIN, security code, HSM secret, etc. method ConfirmationMethod The method used to protect the token ConfirmationMethod \u00b6 Confirmation method type for two-factor workflows Name Number Description None 0 No confirmation required Email 1 Email confirmation required Sms 2 SMS confirmation required ConnectedDevice 3 Confirmation from a connected device is required Other 10 Indicates third-party method of confirmation is required Account \u00b6 Method Name Request Type Response Type Description SignIn SignInRequest SignInResponse Sign in to an already existing account rpc SIgnInConfirm (SignInConfirmRequest) returns (SignInConfirmResponse); | | Info | InfoRequest | InfoResponse | Get account information | | ListDevices | ListDevicesRequest | ListDevicesResponse | List all connected devices | | RevokeDevice | RevokeDeviceRequest | RevokeDeviceResponse | Revoke device access to the account's cloud wallet | Top services/common/v1/common.proto \u00b6 Nonce \u00b6 Nonce used to generate an oberon proof Field Type Label Description timestamp int64 UTC unix millisecond timestamp the request was made request_hash bytes blake3256 hash of the request body ServerConfig \u00b6 Field Type Label Description endpoint string service endpoint port int32 service port use_tls bool indicates if tls is used ResponseStatus \u00b6 Name Number Description SUCCESS 0 WALLET_ACCESS_DENIED 10 WALLET_EXISTS 11 ITEM_NOT_FOUND 20 SERIALIZATION_ERROR 200 UNKNOWN_ERROR 100 Common \u00b6 Method Name Request Type Response Type Description Request .pbmse.v1.EncryptedMessage .pbmse.v1.EncryptedMessage Top services/debug/v1/debug.proto \u00b6 Debugging \u00b6 Method Name Request Type Response Type Description CallEmpty .google.protobuf.Empty .google.protobuf.Empty CallEmptyAuth .google.protobuf.Empty .google.protobuf.Empty Top services/provider/v1/provider.proto \u00b6 CreateEcosystemRequest \u00b6 Field Type Label Description name string Globally unique name for the Ecosystem. This name will be part of the ecosystem specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen. description string Ecosystem description. This field is optional. uri string External URL associated with your organization or ecosystem entity. This field is optional details services.account.v1.AccountDetails The account details of the owner of the ecosystem CreateEcosystemResponse \u00b6 Field Type Label Description ecosystem Ecosystem Details of the created ecosystem profile services.account.v1.AccountProfile Account profile for auth of the owner of the ecosystem confirmation_method services.account.v1.ConfirmationMethod Indicates if confirmation of account is required. This settings is configured globally by the server administrator. Ecosystem \u00b6 Field Type Label Description id string name string description string uri string GenerateTokenRequest \u00b6 Field Type Label Description description string Optional description to identify this token GenerateTokenResponse \u00b6 Field Type Label Description profile services.account.v1.AccountProfile Account authentication profile that contains unprotected token InvitationStatusRequest \u00b6 Request details for the status of onboarding an individual or organization. The reference_id passed is the response from the Onboard method call Field Type Label Description invitation_id string InvitationStatusResponse \u00b6 Field Type Label Description status InvitationStatusResponse.Status status_details string Invite \u00b6 Field Type Label Description id string code string created string accepted string expires string InviteRequest \u00b6 Field Type Label Description participant ParticipantType description string details services.account.v1.AccountDetails InviteRequest.DidCommInvitation \u00b6 InviteResponse \u00b6 Field Type Label Description status services.common.v1.ResponseStatus invitation_id string invitation_code string Invitation Code that must be passed with the account 'SignIn' request to correlate this user with the invitation sent. InvitationStatusResponse.Status \u00b6 Name Number Description Error 0 Onboarding resulted in error InvitationSent 1 The participant has been invited Completed 2 The participant has been onboarded Expired 3 The invite has expired ParticipantType \u00b6 Name Number Description participant_type_individual 0 participant_type_organization 1 Provider \u00b6 Method Name Request Type Response Type Description CreateEcosystem CreateEcosystemRequest CreateEcosystemResponse Create new ecosystem and assign the authenticated user as owner GenerateToken GenerateTokenRequest GenerateTokenResponse Generates an unprotected authentication token that can be used to configure server side applications Invite InviteRequest InviteResponse Invite a user to the ecosystem InvitationStatus InvitationStatusRequest InvitationStatusResponse Check the invitation status Top services/trust-registry/v1/trust-registry.proto \u00b6 AddFrameworkRequest \u00b6 Field Type Label Description governance_framework GovernanceFramework AddFrameworkResponse \u00b6 Field Type Label Description status services.common.v1.ResponseStatus CheckIssuerStatusRequest \u00b6 Field Type Label Description governance_framework_uri string did_uri string x509_cert string credential_type_uri string CheckIssuerStatusResponse \u00b6 Field Type Label Description status RegistrationStatus CheckVerifierStatusRequest \u00b6 Field Type Label Description governance_framework_uri string did_uri string x509_cert string presentation_type_uri string CheckVerifierStatusResponse \u00b6 Field Type Label Description status RegistrationStatus FetchDataRequest \u00b6 Field Type Label Description governance_framework_uri string query string FetchDataResponse \u00b6 Field Type Label Description response_json string has_more_results bool continuation_token string GovernanceFramework \u00b6 Field Type Label Description governance_framework_uri string trust_registry_uri string description string RegisterIssuerRequest \u00b6 Field Type Label Description did_uri string x509_cert string credential_type_uri string valid_from_utc uint64 valid_until_utc uint64 governance_framework_uri string RegisterIssuerResponse \u00b6 Field Type Label Description status services.common.v1.ResponseStatus RegisterVerifierRequest \u00b6 Field Type Label Description did_uri string x509_cert string presentation_type_uri string valid_from_utc uint64 valid_until_utc uint64 governance_framework_uri string RegisterVerifierResponse \u00b6 Field Type Label Description status services.common.v1.ResponseStatus RemoveFrameworkRequest \u00b6 Field Type Label Description governance_framework GovernanceFramework RemoveFrameworkResponse \u00b6 Field Type Label Description status services.common.v1.ResponseStatus SearchRegistryRequest \u00b6 Field Type Label Description query string SELECT c from c where c.type == 'GovernanceFramework' continuation_token string SearchRegistryResponse \u00b6 Field Type Label Description items_json string has_more bool count int32 continuation_token string UnregisterIssuerRequest \u00b6 Field Type Label Description did_uri string x509_cert string credential_type_uri string governance_framework_uri string UnregisterIssuerResponse \u00b6 Field Type Label Description status services.common.v1.ResponseStatus UnregisterVerifierRequest \u00b6 Field Type Label Description did_uri string x509_cert string presentation_type_uri string governance_framework_uri string UnregisterVerifierResponse \u00b6 Field Type Label Description status services.common.v1.ResponseStatus RegistrationStatus \u00b6 Name Number Description CURRENT 0 - the entity is currently authorized, as of time of the query. EXPIRED 1 - entity rights have expired. TERMINATED 2 - entity has voluntarily ceased Issuer role under the specific EGF. REVOKED 3 - entity authority under specific EGF was terminated by the governing authority. NOT_FOUND 10 TrustRegistry \u00b6 Method Name Request Type Response Type Description AddFramework AddFrameworkRequest AddFrameworkResponse Adds a trust registry defintion to the ecosystem RemoveFramework RemoveFrameworkRequest RemoveFrameworkResponse SearchRegistry SearchRegistryRequest SearchRegistryResponse RegisterIssuer RegisterIssuerRequest RegisterIssuerResponse Registers an authoritative issuer with a credential template RegisterVerifier RegisterVerifierRequest RegisterVerifierResponse Registers an authoritative verifier with a credential template UnregisterIssuer UnregisterIssuerRequest UnregisterIssuerResponse Removes an authoritative issuer with a credential template from the trust registry UnregisterVerifier UnregisterVerifierRequest UnregisterVerifierResponse Removes an authoritative verifier with a presentation template from the trust registry CheckIssuerStatus CheckIssuerStatusRequest CheckIssuerStatusResponse CheckVerifierStatus CheckVerifierStatusRequest CheckVerifierStatusResponse FetchData FetchDataRequest FetchDataResponse stream Top services/universal-wallet/v1/universal-wallet.proto \u00b6 DeleteItemRequest \u00b6 Delete item request Field Type Label Description item_id string item identifier of the record to delete DeleteItemResponse \u00b6 Delete item response Field Type Label Description status services.common.v1.ResponseStatus GetItemRequest \u00b6 Get item request object Field Type Label Description item_id string The item identifier GetItemResponse \u00b6 Get item response object Field Type Label Description item_json string The item data represented as stringified JSON item_type string User set item type that described the content of this item InsertItemRequest \u00b6 Insert item request Field Type Label Description item_json string the document to insert as stringified json item_type string optional item type ex. \"VerifiableCredential\" InsertItemResponse \u00b6 Insert item response Field Type Label Description status services.common.v1.ResponseStatus item_id string The item identifier of the inserted record SearchRequest \u00b6 Search request object Field Type Label Description query string continuation_token string SearchResponse \u00b6 Search response object Field Type Label Description items string repeated has_more bool count int32 continuation_token string UpdateItemRequest \u00b6 Update item request object Field Type Label Description item_id string The item identifier item_type string The item type that described the content of this item UpdateItemResponse \u00b6 Update item response object Field Type Label Description status services.common.v1.ResponseStatus Response status UniversalWallet \u00b6 Method Name Request Type Response Type Description GetItem GetItemRequest GetItemResponse Retrieve an item from the wallet with a given item identifier Search SearchRequest SearchResponse Search the wallet using a SQL-like syntax InsertItem InsertItemRequest InsertItemResponse Insert an item into the wallet UpdateItem UpdateItemRequest UpdateItemResponse Insert an item into the wallet DeleteItem DeleteItemRequest DeleteItemResponse Delete an item from the wallet permanently Top services/verifiable-credentials/templates/v1/templates.proto \u00b6 CreateCredentialTemplateRequest \u00b6 Request to create new template Field Type Label Description name string fields CreateCredentialTemplateRequest.FieldsEntry repeated allow_additional_fields bool CreateCredentialTemplateRequest.FieldsEntry \u00b6 Field Type Label Description key string value TemplateField CreateCredentialTemplateResponse \u00b6 Field Type Label Description data TemplateData DeleteCredentialTemplateRequest \u00b6 Field Type Label Description id string DeleteCredentialTemplateResponse \u00b6 GetCredentialTemplateRequest \u00b6 Field Type Label Description id string GetCredentialTemplateResponse \u00b6 Field Type Label Description template TemplateData GetTemplateRequest \u00b6 Field Type Label Description id string GetTemplateResponse \u00b6 Field Type Label Description data TemplateData ListCredentialTemplatesRequest \u00b6 Field Type Label Description query string SELECT * FROM c WHERE c.name = 'Diploma' continuation_token string ListCredentialTemplatesResponse \u00b6 Field Type Label Description templates TemplateData repeated has_more_results bool continuation_token string ListTemplatesRequest \u00b6 ListTemplatesResponse \u00b6 Field Type Label Description templates TemplateData repeated SearchCredentialTemplatesRequest \u00b6 Field Type Label Description query string SELECT * FROM c WHERE c.name = 'Diploma' continuation_token string SearchCredentialTemplatesResponse \u00b6 Field Type Label Description items_json string has_more bool count int32 continuation_token string TemplateData \u00b6 Field Type Label Description id string name string version int32 fields TemplateData.FieldsEntry repeated allow_additional_fields bool schema_uri string context_uri string ecosystem_id string type string TemplateData.FieldsEntry \u00b6 Field Type Label Description key string value TemplateField TemplateField \u00b6 Field Type Label Description description string optional bool type FieldType FieldType \u00b6 Name Number Description STRING 0 NUMBER 1 BOOL 2 DATETIME 4 CredentialTemplates \u00b6 Method Name Request Type Response Type Description Create CreateCredentialTemplateRequest CreateCredentialTemplateResponse Get GetCredentialTemplateRequest GetCredentialTemplateResponse List ListCredentialTemplatesRequest ListCredentialTemplatesResponse Search SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse Delete DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse Top services/verifiable-credentials/v1/verifiable-credentials.proto \u00b6 CheckStatusRequest \u00b6 request object to update the status of the revocation entry Field Type Label Description credential_status_id string the credential status id CheckStatusResponse \u00b6 response object for update of status of revocation entry Field Type Label Description revoked bool indicates if the status is revoked CreateProofRequest \u00b6 Create Proof Field Type Label Description reveal_document_json string Optional document that describes which fields should be revealed in the generated proof. If specified, this document must be a valid JSON-LD frame. If this field is not specified, a default reveal document will be used and all fields in the signed document will be revealed item_id string The item identifier that contains a record with a verifiable credential to be used for generating the proof. document_json string A document that contains a valid verifiable credential with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet. CreateProofResponse \u00b6 Field Type Label Description proof_document_json string IssueFromTemplateRequest \u00b6 Field Type Label Description template_id string values_json string IssueFromTemplateResponse \u00b6 Field Type Label Description document_json string IssueRequest \u00b6 Field Type Label Description document_json string IssueResponse \u00b6 Field Type Label Description signed_document_json string SendRequest \u00b6 Field Type Label Description email string did_uri string didcomm_invitation_json string document_json string SendResponse \u00b6 Field Type Label Description status services.common.v1.ResponseStatus UpdateStatusRequest \u00b6 request object to update the status of the revocation entry Field Type Label Description credential_status_id string the credential status id revoked bool indicates if the status is revoked UpdateStatusResponse \u00b6 response object for update of status of revocation entry Field Type Label Description status services.common.v1.ResponseStatus VerifyProofRequest \u00b6 Verify Proof Field Type Label Description proof_document_json string VerifyProofResponse \u00b6 Field Type Label Description is_valid bool Indicates if the proof is valid validation_messages string repeated Validation messages that describe invalid verifications based on different factors, such as schema validation, proof verification, revocation registry membership, etc. If the proof is not valid, this field will contain detailed results where this verification failed. VerifiableCredential \u00b6 Method Name Request Type Response Type Description Issue IssueRequest IssueResponse Sign and issue a verifiable credential from a submitted document. The document must be a valid JSON-LD document. IssueFromTemplate IssueFromTemplateRequest IssueFromTemplateResponse Sign and issue a verifiable credential from a pre-defined template. This process will also add schema validation and revocation registry entry in the credential. CheckStatus CheckStatusRequest CheckStatusResponse Check credential status by setting the revocation value UpdateStatus UpdateStatusRequest UpdateStatusResponse Update credential status by setting the revocation value CreateProof CreateProofRequest CreateProofResponse Create a proof from a signed document that is a valid verifiable credential and contains a signature from which a proof can be derived. VerifyProof VerifyProofRequest VerifyProofResponse Verifies a proof by checking the signature value, and if possible schema validation, revocation status, and issuer status against a trust registry Send SendRequest SendResponse Sends a document directly to a user's email within the given ecosystem Scalar Value Types \u00b6 .proto Type Notes C++ Java Python Go C# PHP Ruby double double double float float64 double float Float float float float float float32 float float Float int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required) int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required) uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required) sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required) sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required) fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required) sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum bool bool boolean boolean bool bool boolean TrueClass/FalseClass string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8) bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Protocol Buffers"},{"location":"reference/proto/#protocol-documentation","text":"","title":"Protocol Documentation"},{"location":"reference/proto/#table-of-contents","text":"pbmse/v1/pbmse.proto EncryptedMessage EncryptionHeader EncryptionRecipient Signature SignatureHeader SignedMessage EncryptionAlgorithm EncryptionMode sdk/options/v1/options.proto ServiceOptions services/account/v1/account.proto AccountDetails AccountEcosystem AccountProfile InfoRequest InfoResponse ListDevicesRequest ListDevicesResponse RevokeDeviceRequest RevokeDeviceResponse SignInRequest SignInResponse TokenProtection ConfirmationMethod Account services/common/v1/common.proto Nonce ServerConfig ResponseStatus Common services/debug/v1/debug.proto Debugging services/provider/v1/provider.proto CreateEcosystemRequest CreateEcosystemResponse Ecosystem GenerateTokenRequest GenerateTokenResponse InvitationStatusRequest InvitationStatusResponse Invite InviteRequest InviteRequest.DidCommInvitation InviteResponse InvitationStatusResponse.Status ParticipantType Provider services/trust-registry/v1/trust-registry.proto AddFrameworkRequest AddFrameworkResponse CheckIssuerStatusRequest CheckIssuerStatusResponse CheckVerifierStatusRequest CheckVerifierStatusResponse FetchDataRequest FetchDataResponse GovernanceFramework RegisterIssuerRequest RegisterIssuerResponse RegisterVerifierRequest RegisterVerifierResponse RemoveFrameworkRequest RemoveFrameworkResponse SearchRegistryRequest SearchRegistryResponse UnregisterIssuerRequest UnregisterIssuerResponse UnregisterVerifierRequest UnregisterVerifierResponse RegistrationStatus TrustRegistry services/universal-wallet/v1/universal-wallet.proto DeleteItemRequest DeleteItemResponse GetItemRequest GetItemResponse InsertItemRequest InsertItemResponse SearchRequest SearchResponse UpdateItemRequest UpdateItemResponse UniversalWallet services/verifiable-credentials/templates/v1/templates.proto CreateCredentialTemplateRequest CreateCredentialTemplateRequest.FieldsEntry CreateCredentialTemplateResponse DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse GetCredentialTemplateRequest GetCredentialTemplateResponse GetTemplateRequest GetTemplateResponse ListCredentialTemplatesRequest ListCredentialTemplatesResponse ListTemplatesRequest ListTemplatesResponse SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse TemplateData TemplateData.FieldsEntry TemplateField FieldType CredentialTemplates services/verifiable-credentials/v1/verifiable-credentials.proto CheckStatusRequest CheckStatusResponse CreateProofRequest CreateProofResponse IssueFromTemplateRequest IssueFromTemplateResponse IssueRequest IssueResponse SendRequest SendResponse UpdateStatusRequest UpdateStatusResponse VerifyProofRequest VerifyProofResponse VerifiableCredential Scalar Value Types Top","title":"Table of Contents"},{"location":"reference/proto/#pbmsev1pbmseproto","text":"","title":"pbmse/v1/pbmse.proto"},{"location":"reference/proto/#encryptedmessage","text":"Field Type Label Description iv bytes aad bytes ciphertext bytes tag bytes recipients EncryptionRecipient repeated","title":"EncryptedMessage"},{"location":"reference/proto/#encryptionheader","text":"Field Type Label Description mode EncryptionMode algorithm EncryptionAlgorithm key_id string sender_key_id string","title":"EncryptionHeader"},{"location":"reference/proto/#encryptionrecipient","text":"Field Type Label Description header EncryptionHeader content_encryption_key bytes","title":"EncryptionRecipient"},{"location":"reference/proto/#signature","text":"Field Type Label Description header bytes signature bytes","title":"Signature"},{"location":"reference/proto/#signatureheader","text":"Field Type Label Description algorithm string key_id string","title":"SignatureHeader"},{"location":"reference/proto/#signedmessage","text":"JWS Protocol buffer message signing and encryption Field Type Label Description payload bytes signatures Signature repeated","title":"SignedMessage"},{"location":"reference/proto/#encryptionalgorithm","text":"Name Number Description ENCRYPTION_ALGORITHM_UNSPECIFIED 0 ENCRYPTION_ALGORITHM_XCHACHA20POLY1305 1 ENCRYPTION_ALGORITHM_AES_GCM 2","title":"EncryptionAlgorithm"},{"location":"reference/proto/#encryptionmode","text":"Name Number Description ENCRYPTION_MODE_UNSPECIFIED 0 ENCRYPTION_MODE_DIRECT 1 ENCRYPTION_MODE_CONTENT_ENCRYPTION_KEY 2 Top","title":"EncryptionMode"},{"location":"reference/proto/#sdkoptionsv1optionsproto","text":"","title":"sdk/options/v1/options.proto"},{"location":"reference/proto/#serviceoptions","text":"service options Field Type Label Description server_endpoint string service endpoint server_port int32 service port server_use_tls bool indicates if tls is used auth_token string default auth token for oberon security scheme default_ecosystem string ecosystem to use with endpoints that require it Top","title":"ServiceOptions"},{"location":"reference/proto/#servicesaccountv1accountproto","text":"","title":"services/account/v1/account.proto"},{"location":"reference/proto/#accountdetails","text":"Account Registration Details Field Type Label Description name string Account name (optional) email string Email account (required) sms string SMS number including country code (optional)","title":"AccountDetails"},{"location":"reference/proto/#accountecosystem","text":"Field Type Label Description id string name string description string uri string","title":"AccountEcosystem"},{"location":"reference/proto/#accountprofile","text":"Device profile containing sensitive authentication data. This information should be stored securely Field Type Label Description profile_type string The type of profile, used to differentiate between protocol schemes or versions auth_data bytes Auth data containg information about the current device access auth_token bytes Secure token issued by server used to generate zero-knowledge proofs protection TokenProtection Token security information about the token. If token protection is enabled, implementations must supply protection secret before using the token for authentication.","title":"AccountProfile"},{"location":"reference/proto/#inforequest","text":"","title":"InfoRequest"},{"location":"reference/proto/#inforesponse","text":"Field Type Label Description details AccountDetails The account details associated with the calling request context ecosystems AccountEcosystem repeated any ecosystems the account has access to","title":"InfoResponse"},{"location":"reference/proto/#listdevicesrequest","text":"","title":"ListDevicesRequest"},{"location":"reference/proto/#listdevicesresponse","text":"","title":"ListDevicesResponse"},{"location":"reference/proto/#revokedevicerequest","text":"","title":"RevokeDeviceRequest"},{"location":"reference/proto/#revokedeviceresponse","text":"","title":"RevokeDeviceResponse"},{"location":"reference/proto/#signinrequest","text":"Request for creating new account Field Type Label Description details AccountDetails Account registration details invitation_code string Invitation code associated with this registration This field is optional. ecosystem_id string EcosystemId to sign in. This field is optional and will be ignored if invitation_code is passed","title":"SignInRequest"},{"location":"reference/proto/#signinresponse","text":"Response for creating new account This object will indicate if a confirmation code was sent to one of the users two-factor methods like email, SMS, etc. Field Type Label Description status services.common.v1.ResponseStatus The status of the response confirmation_method ConfirmationMethod Indicates if confirmation of account is required. This settings is configured globally by the server administrator. profile AccountProfile Contains authentication data for use with the current device. This object must be stored in a secure place. It can also be protected with a PIN, but this is optional. See the docs at https://docs.trinsic.id for more information on working with authentication data.","title":"SignInResponse"},{"location":"reference/proto/#tokenprotection","text":"Token protection info Field Type Label Description enabled bool Indicates if token is protected using a PIN, security code, HSM secret, etc. method ConfirmationMethod The method used to protect the token","title":"TokenProtection"},{"location":"reference/proto/#confirmationmethod","text":"Confirmation method type for two-factor workflows Name Number Description None 0 No confirmation required Email 1 Email confirmation required Sms 2 SMS confirmation required ConnectedDevice 3 Confirmation from a connected device is required Other 10 Indicates third-party method of confirmation is required","title":"ConfirmationMethod"},{"location":"reference/proto/#account","text":"Method Name Request Type Response Type Description SignIn SignInRequest SignInResponse Sign in to an already existing account rpc SIgnInConfirm (SignInConfirmRequest) returns (SignInConfirmResponse); | | Info | InfoRequest | InfoResponse | Get account information | | ListDevices | ListDevicesRequest | ListDevicesResponse | List all connected devices | | RevokeDevice | RevokeDeviceRequest | RevokeDeviceResponse | Revoke device access to the account's cloud wallet | Top","title":"Account"},{"location":"reference/proto/#servicescommonv1commonproto","text":"","title":"services/common/v1/common.proto"},{"location":"reference/proto/#nonce","text":"Nonce used to generate an oberon proof Field Type Label Description timestamp int64 UTC unix millisecond timestamp the request was made request_hash bytes blake3256 hash of the request body","title":"Nonce"},{"location":"reference/proto/#serverconfig","text":"Field Type Label Description endpoint string service endpoint port int32 service port use_tls bool indicates if tls is used","title":"ServerConfig"},{"location":"reference/proto/#responsestatus","text":"Name Number Description SUCCESS 0 WALLET_ACCESS_DENIED 10 WALLET_EXISTS 11 ITEM_NOT_FOUND 20 SERIALIZATION_ERROR 200 UNKNOWN_ERROR 100","title":"ResponseStatus"},{"location":"reference/proto/#common","text":"Method Name Request Type Response Type Description Request .pbmse.v1.EncryptedMessage .pbmse.v1.EncryptedMessage Top","title":"Common"},{"location":"reference/proto/#servicesdebugv1debugproto","text":"","title":"services/debug/v1/debug.proto"},{"location":"reference/proto/#debugging","text":"Method Name Request Type Response Type Description CallEmpty .google.protobuf.Empty .google.protobuf.Empty CallEmptyAuth .google.protobuf.Empty .google.protobuf.Empty Top","title":"Debugging"},{"location":"reference/proto/#servicesproviderv1providerproto","text":"","title":"services/provider/v1/provider.proto"},{"location":"reference/proto/#createecosystemrequest","text":"Field Type Label Description name string Globally unique name for the Ecosystem. This name will be part of the ecosystem specific URLs and namespaces. Allowed characters are lowercase letters, numbers, underscore and hyphen. description string Ecosystem description. This field is optional. uri string External URL associated with your organization or ecosystem entity. This field is optional details services.account.v1.AccountDetails The account details of the owner of the ecosystem","title":"CreateEcosystemRequest"},{"location":"reference/proto/#createecosystemresponse","text":"Field Type Label Description ecosystem Ecosystem Details of the created ecosystem profile services.account.v1.AccountProfile Account profile for auth of the owner of the ecosystem confirmation_method services.account.v1.ConfirmationMethod Indicates if confirmation of account is required. This settings is configured globally by the server administrator.","title":"CreateEcosystemResponse"},{"location":"reference/proto/#ecosystem","text":"Field Type Label Description id string name string description string uri string","title":"Ecosystem"},{"location":"reference/proto/#generatetokenrequest","text":"Field Type Label Description description string Optional description to identify this token","title":"GenerateTokenRequest"},{"location":"reference/proto/#generatetokenresponse","text":"Field Type Label Description profile services.account.v1.AccountProfile Account authentication profile that contains unprotected token","title":"GenerateTokenResponse"},{"location":"reference/proto/#invitationstatusrequest","text":"Request details for the status of onboarding an individual or organization. The reference_id passed is the response from the Onboard method call Field Type Label Description invitation_id string","title":"InvitationStatusRequest"},{"location":"reference/proto/#invitationstatusresponse","text":"Field Type Label Description status InvitationStatusResponse.Status status_details string","title":"InvitationStatusResponse"},{"location":"reference/proto/#invite","text":"Field Type Label Description id string code string created string accepted string expires string","title":"Invite"},{"location":"reference/proto/#inviterequest","text":"Field Type Label Description participant ParticipantType description string details services.account.v1.AccountDetails","title":"InviteRequest"},{"location":"reference/proto/#inviterequestdidcomminvitation","text":"","title":"InviteRequest.DidCommInvitation"},{"location":"reference/proto/#inviteresponse","text":"Field Type Label Description status services.common.v1.ResponseStatus invitation_id string invitation_code string Invitation Code that must be passed with the account 'SignIn' request to correlate this user with the invitation sent.","title":"InviteResponse"},{"location":"reference/proto/#invitationstatusresponsestatus","text":"Name Number Description Error 0 Onboarding resulted in error InvitationSent 1 The participant has been invited Completed 2 The participant has been onboarded Expired 3 The invite has expired","title":"InvitationStatusResponse.Status"},{"location":"reference/proto/#participanttype","text":"Name Number Description participant_type_individual 0 participant_type_organization 1","title":"ParticipantType"},{"location":"reference/proto/#provider","text":"Method Name Request Type Response Type Description CreateEcosystem CreateEcosystemRequest CreateEcosystemResponse Create new ecosystem and assign the authenticated user as owner GenerateToken GenerateTokenRequest GenerateTokenResponse Generates an unprotected authentication token that can be used to configure server side applications Invite InviteRequest InviteResponse Invite a user to the ecosystem InvitationStatus InvitationStatusRequest InvitationStatusResponse Check the invitation status Top","title":"Provider"},{"location":"reference/proto/#servicestrust-registryv1trust-registryproto","text":"","title":"services/trust-registry/v1/trust-registry.proto"},{"location":"reference/proto/#addframeworkrequest","text":"Field Type Label Description governance_framework GovernanceFramework","title":"AddFrameworkRequest"},{"location":"reference/proto/#addframeworkresponse","text":"Field Type Label Description status services.common.v1.ResponseStatus","title":"AddFrameworkResponse"},{"location":"reference/proto/#checkissuerstatusrequest","text":"Field Type Label Description governance_framework_uri string did_uri string x509_cert string credential_type_uri string","title":"CheckIssuerStatusRequest"},{"location":"reference/proto/#checkissuerstatusresponse","text":"Field Type Label Description status RegistrationStatus","title":"CheckIssuerStatusResponse"},{"location":"reference/proto/#checkverifierstatusrequest","text":"Field Type Label Description governance_framework_uri string did_uri string x509_cert string presentation_type_uri string","title":"CheckVerifierStatusRequest"},{"location":"reference/proto/#checkverifierstatusresponse","text":"Field Type Label Description status RegistrationStatus","title":"CheckVerifierStatusResponse"},{"location":"reference/proto/#fetchdatarequest","text":"Field Type Label Description governance_framework_uri string query string","title":"FetchDataRequest"},{"location":"reference/proto/#fetchdataresponse","text":"Field Type Label Description response_json string has_more_results bool continuation_token string","title":"FetchDataResponse"},{"location":"reference/proto/#governanceframework","text":"Field Type Label Description governance_framework_uri string trust_registry_uri string description string","title":"GovernanceFramework"},{"location":"reference/proto/#registerissuerrequest","text":"Field Type Label Description did_uri string x509_cert string credential_type_uri string valid_from_utc uint64 valid_until_utc uint64 governance_framework_uri string","title":"RegisterIssuerRequest"},{"location":"reference/proto/#registerissuerresponse","text":"Field Type Label Description status services.common.v1.ResponseStatus","title":"RegisterIssuerResponse"},{"location":"reference/proto/#registerverifierrequest","text":"Field Type Label Description did_uri string x509_cert string presentation_type_uri string valid_from_utc uint64 valid_until_utc uint64 governance_framework_uri string","title":"RegisterVerifierRequest"},{"location":"reference/proto/#registerverifierresponse","text":"Field Type Label Description status services.common.v1.ResponseStatus","title":"RegisterVerifierResponse"},{"location":"reference/proto/#removeframeworkrequest","text":"Field Type Label Description governance_framework GovernanceFramework","title":"RemoveFrameworkRequest"},{"location":"reference/proto/#removeframeworkresponse","text":"Field Type Label Description status services.common.v1.ResponseStatus","title":"RemoveFrameworkResponse"},{"location":"reference/proto/#searchregistryrequest","text":"Field Type Label Description query string SELECT c from c where c.type == 'GovernanceFramework' continuation_token string","title":"SearchRegistryRequest"},{"location":"reference/proto/#searchregistryresponse","text":"Field Type Label Description items_json string has_more bool count int32 continuation_token string","title":"SearchRegistryResponse"},{"location":"reference/proto/#unregisterissuerrequest","text":"Field Type Label Description did_uri string x509_cert string credential_type_uri string governance_framework_uri string","title":"UnregisterIssuerRequest"},{"location":"reference/proto/#unregisterissuerresponse","text":"Field Type Label Description status services.common.v1.ResponseStatus","title":"UnregisterIssuerResponse"},{"location":"reference/proto/#unregisterverifierrequest","text":"Field Type Label Description did_uri string x509_cert string presentation_type_uri string governance_framework_uri string","title":"UnregisterVerifierRequest"},{"location":"reference/proto/#unregisterverifierresponse","text":"Field Type Label Description status services.common.v1.ResponseStatus","title":"UnregisterVerifierResponse"},{"location":"reference/proto/#registrationstatus","text":"Name Number Description CURRENT 0 - the entity is currently authorized, as of time of the query. EXPIRED 1 - entity rights have expired. TERMINATED 2 - entity has voluntarily ceased Issuer role under the specific EGF. REVOKED 3 - entity authority under specific EGF was terminated by the governing authority. NOT_FOUND 10","title":"RegistrationStatus"},{"location":"reference/proto/#trustregistry","text":"Method Name Request Type Response Type Description AddFramework AddFrameworkRequest AddFrameworkResponse Adds a trust registry defintion to the ecosystem RemoveFramework RemoveFrameworkRequest RemoveFrameworkResponse SearchRegistry SearchRegistryRequest SearchRegistryResponse RegisterIssuer RegisterIssuerRequest RegisterIssuerResponse Registers an authoritative issuer with a credential template RegisterVerifier RegisterVerifierRequest RegisterVerifierResponse Registers an authoritative verifier with a credential template UnregisterIssuer UnregisterIssuerRequest UnregisterIssuerResponse Removes an authoritative issuer with a credential template from the trust registry UnregisterVerifier UnregisterVerifierRequest UnregisterVerifierResponse Removes an authoritative verifier with a presentation template from the trust registry CheckIssuerStatus CheckIssuerStatusRequest CheckIssuerStatusResponse CheckVerifierStatus CheckVerifierStatusRequest CheckVerifierStatusResponse FetchData FetchDataRequest FetchDataResponse stream Top","title":"TrustRegistry"},{"location":"reference/proto/#servicesuniversal-walletv1universal-walletproto","text":"","title":"services/universal-wallet/v1/universal-wallet.proto"},{"location":"reference/proto/#deleteitemrequest","text":"Delete item request Field Type Label Description item_id string item identifier of the record to delete","title":"DeleteItemRequest"},{"location":"reference/proto/#deleteitemresponse","text":"Delete item response Field Type Label Description status services.common.v1.ResponseStatus","title":"DeleteItemResponse"},{"location":"reference/proto/#getitemrequest","text":"Get item request object Field Type Label Description item_id string The item identifier","title":"GetItemRequest"},{"location":"reference/proto/#getitemresponse","text":"Get item response object Field Type Label Description item_json string The item data represented as stringified JSON item_type string User set item type that described the content of this item","title":"GetItemResponse"},{"location":"reference/proto/#insertitemrequest","text":"Insert item request Field Type Label Description item_json string the document to insert as stringified json item_type string optional item type ex. \"VerifiableCredential\"","title":"InsertItemRequest"},{"location":"reference/proto/#insertitemresponse","text":"Insert item response Field Type Label Description status services.common.v1.ResponseStatus item_id string The item identifier of the inserted record","title":"InsertItemResponse"},{"location":"reference/proto/#searchrequest","text":"Search request object Field Type Label Description query string continuation_token string","title":"SearchRequest"},{"location":"reference/proto/#searchresponse","text":"Search response object Field Type Label Description items string repeated has_more bool count int32 continuation_token string","title":"SearchResponse"},{"location":"reference/proto/#updateitemrequest","text":"Update item request object Field Type Label Description item_id string The item identifier item_type string The item type that described the content of this item","title":"UpdateItemRequest"},{"location":"reference/proto/#updateitemresponse","text":"Update item response object Field Type Label Description status services.common.v1.ResponseStatus Response status","title":"UpdateItemResponse"},{"location":"reference/proto/#universalwallet","text":"Method Name Request Type Response Type Description GetItem GetItemRequest GetItemResponse Retrieve an item from the wallet with a given item identifier Search SearchRequest SearchResponse Search the wallet using a SQL-like syntax InsertItem InsertItemRequest InsertItemResponse Insert an item into the wallet UpdateItem UpdateItemRequest UpdateItemResponse Insert an item into the wallet DeleteItem DeleteItemRequest DeleteItemResponse Delete an item from the wallet permanently Top","title":"UniversalWallet"},{"location":"reference/proto/#servicesverifiable-credentialstemplatesv1templatesproto","text":"","title":"services/verifiable-credentials/templates/v1/templates.proto"},{"location":"reference/proto/#createcredentialtemplaterequest","text":"Request to create new template Field Type Label Description name string fields CreateCredentialTemplateRequest.FieldsEntry repeated allow_additional_fields bool","title":"CreateCredentialTemplateRequest"},{"location":"reference/proto/#createcredentialtemplaterequestfieldsentry","text":"Field Type Label Description key string value TemplateField","title":"CreateCredentialTemplateRequest.FieldsEntry"},{"location":"reference/proto/#createcredentialtemplateresponse","text":"Field Type Label Description data TemplateData","title":"CreateCredentialTemplateResponse"},{"location":"reference/proto/#deletecredentialtemplaterequest","text":"Field Type Label Description id string","title":"DeleteCredentialTemplateRequest"},{"location":"reference/proto/#deletecredentialtemplateresponse","text":"","title":"DeleteCredentialTemplateResponse"},{"location":"reference/proto/#getcredentialtemplaterequest","text":"Field Type Label Description id string","title":"GetCredentialTemplateRequest"},{"location":"reference/proto/#getcredentialtemplateresponse","text":"Field Type Label Description template TemplateData","title":"GetCredentialTemplateResponse"},{"location":"reference/proto/#gettemplaterequest","text":"Field Type Label Description id string","title":"GetTemplateRequest"},{"location":"reference/proto/#gettemplateresponse","text":"Field Type Label Description data TemplateData","title":"GetTemplateResponse"},{"location":"reference/proto/#listcredentialtemplatesrequest","text":"Field Type Label Description query string SELECT * FROM c WHERE c.name = 'Diploma' continuation_token string","title":"ListCredentialTemplatesRequest"},{"location":"reference/proto/#listcredentialtemplatesresponse","text":"Field Type Label Description templates TemplateData repeated has_more_results bool continuation_token string","title":"ListCredentialTemplatesResponse"},{"location":"reference/proto/#listtemplatesrequest","text":"","title":"ListTemplatesRequest"},{"location":"reference/proto/#listtemplatesresponse","text":"Field Type Label Description templates TemplateData repeated","title":"ListTemplatesResponse"},{"location":"reference/proto/#searchcredentialtemplatesrequest","text":"Field Type Label Description query string SELECT * FROM c WHERE c.name = 'Diploma' continuation_token string","title":"SearchCredentialTemplatesRequest"},{"location":"reference/proto/#searchcredentialtemplatesresponse","text":"Field Type Label Description items_json string has_more bool count int32 continuation_token string","title":"SearchCredentialTemplatesResponse"},{"location":"reference/proto/#templatedata","text":"Field Type Label Description id string name string version int32 fields TemplateData.FieldsEntry repeated allow_additional_fields bool schema_uri string context_uri string ecosystem_id string type string","title":"TemplateData"},{"location":"reference/proto/#templatedatafieldsentry","text":"Field Type Label Description key string value TemplateField","title":"TemplateData.FieldsEntry"},{"location":"reference/proto/#templatefield","text":"Field Type Label Description description string optional bool type FieldType","title":"TemplateField"},{"location":"reference/proto/#fieldtype","text":"Name Number Description STRING 0 NUMBER 1 BOOL 2 DATETIME 4","title":"FieldType"},{"location":"reference/proto/#credentialtemplates","text":"Method Name Request Type Response Type Description Create CreateCredentialTemplateRequest CreateCredentialTemplateResponse Get GetCredentialTemplateRequest GetCredentialTemplateResponse List ListCredentialTemplatesRequest ListCredentialTemplatesResponse Search SearchCredentialTemplatesRequest SearchCredentialTemplatesResponse Delete DeleteCredentialTemplateRequest DeleteCredentialTemplateResponse Top","title":"CredentialTemplates"},{"location":"reference/proto/#servicesverifiable-credentialsv1verifiable-credentialsproto","text":"","title":"services/verifiable-credentials/v1/verifiable-credentials.proto"},{"location":"reference/proto/#checkstatusrequest","text":"request object to update the status of the revocation entry Field Type Label Description credential_status_id string the credential status id","title":"CheckStatusRequest"},{"location":"reference/proto/#checkstatusresponse","text":"response object for update of status of revocation entry Field Type Label Description revoked bool indicates if the status is revoked","title":"CheckStatusResponse"},{"location":"reference/proto/#createproofrequest","text":"Create Proof Field Type Label Description reveal_document_json string Optional document that describes which fields should be revealed in the generated proof. If specified, this document must be a valid JSON-LD frame. If this field is not specified, a default reveal document will be used and all fields in the signed document will be revealed item_id string The item identifier that contains a record with a verifiable credential to be used for generating the proof. document_json string A document that contains a valid verifiable credential with an unbound signature. The proof will be derived from this document directly. The document will not be stored in the wallet.","title":"CreateProofRequest"},{"location":"reference/proto/#createproofresponse","text":"Field Type Label Description proof_document_json string","title":"CreateProofResponse"},{"location":"reference/proto/#issuefromtemplaterequest","text":"Field Type Label Description template_id string values_json string","title":"IssueFromTemplateRequest"},{"location":"reference/proto/#issuefromtemplateresponse","text":"Field Type Label Description document_json string","title":"IssueFromTemplateResponse"},{"location":"reference/proto/#issuerequest","text":"Field Type Label Description document_json string","title":"IssueRequest"},{"location":"reference/proto/#issueresponse","text":"Field Type Label Description signed_document_json string","title":"IssueResponse"},{"location":"reference/proto/#sendrequest","text":"Field Type Label Description email string did_uri string didcomm_invitation_json string document_json string","title":"SendRequest"},{"location":"reference/proto/#sendresponse","text":"Field Type Label Description status services.common.v1.ResponseStatus","title":"SendResponse"},{"location":"reference/proto/#updatestatusrequest","text":"request object to update the status of the revocation entry Field Type Label Description credential_status_id string the credential status id revoked bool indicates if the status is revoked","title":"UpdateStatusRequest"},{"location":"reference/proto/#updatestatusresponse","text":"response object for update of status of revocation entry Field Type Label Description status services.common.v1.ResponseStatus","title":"UpdateStatusResponse"},{"location":"reference/proto/#verifyproofrequest","text":"Verify Proof Field Type Label Description proof_document_json string","title":"VerifyProofRequest"},{"location":"reference/proto/#verifyproofresponse","text":"Field Type Label Description is_valid bool Indicates if the proof is valid validation_messages string repeated Validation messages that describe invalid verifications based on different factors, such as schema validation, proof verification, revocation registry membership, etc. If the proof is not valid, this field will contain detailed results where this verification failed.","title":"VerifyProofResponse"},{"location":"reference/proto/#verifiablecredential","text":"Method Name Request Type Response Type Description Issue IssueRequest IssueResponse Sign and issue a verifiable credential from a submitted document. The document must be a valid JSON-LD document. IssueFromTemplate IssueFromTemplateRequest IssueFromTemplateResponse Sign and issue a verifiable credential from a pre-defined template. This process will also add schema validation and revocation registry entry in the credential. CheckStatus CheckStatusRequest CheckStatusResponse Check credential status by setting the revocation value UpdateStatus UpdateStatusRequest UpdateStatusResponse Update credential status by setting the revocation value CreateProof CreateProofRequest CreateProofResponse Create a proof from a signed document that is a valid verifiable credential and contains a signature from which a proof can be derived. VerifyProof VerifyProofRequest VerifyProofResponse Verifies a proof by checking the signature value, and if possible schema validation, revocation status, and issuer status against a trust registry Send SendRequest SendResponse Sends a document directly to a user's email within the given ecosystem","title":"VerifiableCredential"},{"location":"reference/proto/#scalar-value-types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby double double double float float64 double float Float float float float float float32 float float Float int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required) int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required) uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required) sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required) sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required) fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required) sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum bool bool boolean boolean bool bool boolean TrueClass/FalseClass string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8) bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Scalar Value Types"},{"location":"reference/services/account-service/","text":"Account Service \u00b6 When you need to manage trinsic account, you will most definitely interface with the Account Service. Below you will find information on how to work with the different procedures pertinent to the account service. Construct Instance \u00b6 If you are using one of Trinsic SDK's, you will need to create an instance of the Account Service in order to use its different procedures/calls. Below you will find how to instantiate the Account Service with default settings, by simply calling the constructor without passing any parameters. TypeScript C# Python Java Ruby const accountService = new AccountService (); var accountService = new AccountService (); account_service = AccountService () var accountService = new AccountService ( null ); account_service = Trinsic :: AccountService . new ( nil , Trinsic :: trinsic_prod_server ) The constructor also accepts an options object as an argument. It follows the same structure of ServiceOptions , with the following properties: Field Type Label Description server_endpoint string service endpoint server_port int32 service port server_use_tls bool indicates if tls is used auth_token string default auth token for oberon security scheme default_ecosystem string ecosystem to use with endpoints that require it The exact structure of such object will depend on the language you are working with. You can always rely on your editor's intellisense when in doubt. Sign In \u00b6 Create login credentials by signing into an existing account or creating a new one. As part of the this procedure, you must provide a Sign In Request object that contains account details information such as name (alias) of the account, email, and an SMS phone number. You may also provide an invitation code and ecosystem ID if you have them. The sign in request should look like this: Field Type Label Description details AccountDetails Account registration details invitation_code string Invitation code associated with this registration This field is optional. ecosystem_id string EcosystemId to sign in. This field is optional and will be ignored if invitation_code is passed And the Account Details object should look like this: Field Type Label Description name string Account name (optional) email string Email account (required) sms string SMS number including country code (optional) Trinsic CLI TypeScript C# Python Go Java Ruby trinsic account login --email <PROFILE_EMAIL> --name <PROFILE_NAME> const allison = ( await accountService . signIn ()). getProfile (); var allison = await accountService . SignInAsync (); allison = await account_service . sign_in () profile , _ , err := accountService . SignIn ( context . Background (), nil ) var allison = accountService . signIn ( null ). get (). getProfile (); allison = account_service . sign_in ( nil ) . profile This operation produces a response that has the structure of a Sign In Response , indicating whether or not a confirmation code was sent to one of the users two-factor methods like email, SMS, etc. (as defined by the Sign In Request). Field Type Label Description status ResponseStatus The status of the response confirmation_method ConfirmationMethod Indicates if confirmation of account is required. profile AccountProfile Contains authentication data for use with the current device. Get Account Info \u00b6 This will returns the account info of the current active profile in the SDK or CLI. This can only be called on a profile that has been unprotected by providing a code that was sent through email or SMS when the account was signed in. Its response is a Info Response object and has the following properties: Field Type Label Description details AccountDetails The account details associated with the calling request context ecosystems AccountEcosystem repeated any ecosystems the account has access to Calling this procedure, is as trivial as evidenced below. Keep it mind, however, that it assumes you have the correct profile active. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic account info const info = await accountService . info (); var info = await accountService . GetInfoAsync (); info = await account_service . get_info () infoResponse , err := accountService . GetInfo ( context . Background ()) var info = accountService . getInfo (). get (); info = account_service . get_info () Protect Account Profile \u00b6 Protects the specified account profile blinding its token using oberon. It is not possible to execute this call using the CLI, and the parameters that you must provide are evidenced in the code snippets below: TypeScript C# Python Go Java Ruby const protectedProfile = await accountService . protect ( accountProfile , \"1234\" ); var protectedProfile = accountService . Protect ( accountProfile , \"1234\" ); protected_profile = account_service . protect ( account_profile , \"1234\" . encode ( 'utf-8' )) protectedProfile , err := accountService . Protect ( accountProfile , \"1234\" ) var protectedProfile = AccountService . protect ( accountProfile , \"1234\" ); protected_profile = account_service . protect ( account_profile , '1234' ) Unprotect Account Profile \u00b6 Unprotects the specified account profile unblinding its token using oberon. It is not possible to execute this call using the CLI, and the parameters that you must provide are evidenced in the code snippets below. Keep in mind, that if this account was signed in using protection, you must provide the code you received in the email or SMS as the securityCode argument. TypeScript C# Python Go Java Ruby const accountProfile = await accountService . unprotect ( protectedProfile , \"1234\" ); var accountProfile = accountService . Unprotect ( protectedProfile , \"1234\" ); account_profile = account_service . unprotect ( protected_profile , \"1234\" . encode ( 'utf-8' )) accountProfile , err := accountService . Unprotect ( protectedProfile , \"1234\" ) var accountProfile = AccountService . unprotect ( protectedProfile , \"1234\" ); account_profile = account_service . unprotect ( protected_profile , '1234' )","title":"Account Service"},{"location":"reference/services/account-service/#account-service","text":"When you need to manage trinsic account, you will most definitely interface with the Account Service. Below you will find information on how to work with the different procedures pertinent to the account service.","title":"Account Service"},{"location":"reference/services/account-service/#construct-instance","text":"If you are using one of Trinsic SDK's, you will need to create an instance of the Account Service in order to use its different procedures/calls. Below you will find how to instantiate the Account Service with default settings, by simply calling the constructor without passing any parameters. TypeScript C# Python Java Ruby const accountService = new AccountService (); var accountService = new AccountService (); account_service = AccountService () var accountService = new AccountService ( null ); account_service = Trinsic :: AccountService . new ( nil , Trinsic :: trinsic_prod_server ) The constructor also accepts an options object as an argument. It follows the same structure of ServiceOptions , with the following properties: Field Type Label Description server_endpoint string service endpoint server_port int32 service port server_use_tls bool indicates if tls is used auth_token string default auth token for oberon security scheme default_ecosystem string ecosystem to use with endpoints that require it The exact structure of such object will depend on the language you are working with. You can always rely on your editor's intellisense when in doubt.","title":"Construct Instance"},{"location":"reference/services/account-service/#sign-in","text":"Create login credentials by signing into an existing account or creating a new one. As part of the this procedure, you must provide a Sign In Request object that contains account details information such as name (alias) of the account, email, and an SMS phone number. You may also provide an invitation code and ecosystem ID if you have them. The sign in request should look like this: Field Type Label Description details AccountDetails Account registration details invitation_code string Invitation code associated with this registration This field is optional. ecosystem_id string EcosystemId to sign in. This field is optional and will be ignored if invitation_code is passed And the Account Details object should look like this: Field Type Label Description name string Account name (optional) email string Email account (required) sms string SMS number including country code (optional) Trinsic CLI TypeScript C# Python Go Java Ruby trinsic account login --email <PROFILE_EMAIL> --name <PROFILE_NAME> const allison = ( await accountService . signIn ()). getProfile (); var allison = await accountService . SignInAsync (); allison = await account_service . sign_in () profile , _ , err := accountService . SignIn ( context . Background (), nil ) var allison = accountService . signIn ( null ). get (). getProfile (); allison = account_service . sign_in ( nil ) . profile This operation produces a response that has the structure of a Sign In Response , indicating whether or not a confirmation code was sent to one of the users two-factor methods like email, SMS, etc. (as defined by the Sign In Request). Field Type Label Description status ResponseStatus The status of the response confirmation_method ConfirmationMethod Indicates if confirmation of account is required. profile AccountProfile Contains authentication data for use with the current device.","title":"Sign In"},{"location":"reference/services/account-service/#get-account-info","text":"This will returns the account info of the current active profile in the SDK or CLI. This can only be called on a profile that has been unprotected by providing a code that was sent through email or SMS when the account was signed in. Its response is a Info Response object and has the following properties: Field Type Label Description details AccountDetails The account details associated with the calling request context ecosystems AccountEcosystem repeated any ecosystems the account has access to Calling this procedure, is as trivial as evidenced below. Keep it mind, however, that it assumes you have the correct profile active. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic account info const info = await accountService . info (); var info = await accountService . GetInfoAsync (); info = await account_service . get_info () infoResponse , err := accountService . GetInfo ( context . Background ()) var info = accountService . getInfo (). get (); info = account_service . get_info ()","title":"Get Account Info"},{"location":"reference/services/account-service/#protect-account-profile","text":"Protects the specified account profile blinding its token using oberon. It is not possible to execute this call using the CLI, and the parameters that you must provide are evidenced in the code snippets below: TypeScript C# Python Go Java Ruby const protectedProfile = await accountService . protect ( accountProfile , \"1234\" ); var protectedProfile = accountService . Protect ( accountProfile , \"1234\" ); protected_profile = account_service . protect ( account_profile , \"1234\" . encode ( 'utf-8' )) protectedProfile , err := accountService . Protect ( accountProfile , \"1234\" ) var protectedProfile = AccountService . protect ( accountProfile , \"1234\" ); protected_profile = account_service . protect ( account_profile , '1234' )","title":"Protect Account Profile"},{"location":"reference/services/account-service/#unprotect-account-profile","text":"Unprotects the specified account profile unblinding its token using oberon. It is not possible to execute this call using the CLI, and the parameters that you must provide are evidenced in the code snippets below. Keep in mind, that if this account was signed in using protection, you must provide the code you received in the email or SMS as the securityCode argument. TypeScript C# Python Go Java Ruby const accountProfile = await accountService . unprotect ( protectedProfile , \"1234\" ); var accountProfile = accountService . Unprotect ( protectedProfile , \"1234\" ); account_profile = account_service . unprotect ( protected_profile , \"1234\" . encode ( 'utf-8' )) accountProfile , err := accountService . Unprotect ( protectedProfile , \"1234\" ) var accountProfile = AccountService . unprotect ( protectedProfile , \"1234\" ); account_profile = account_service . unprotect ( protected_profile , '1234' )","title":"Unprotect Account Profile"},{"location":"reference/services/credential-service/","text":"Credential Service \u00b6 SDK Calls \u00b6 Issue Credential \u00b6 The Credential service supports signing data using BBS+ Signatures . The data is signed with a key unique to the owner's wallet. This key is also used as linked secret, when it comes to proof derivation. This endpoint requires that the user provide a valid JSON-LD document. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic issuer issue --document <INPUT_JSONLD_FILE> --out <OUTPUT_FILE> // Sign a credential as the clinic and send it to Allison const credentialJson = getVaccineCertUnsignedJSON () const credential = await credentialService . issueCredential ( new IssueRequest () . setDocumentJson ( JSON . stringify ( credentialJson ))); var credential = await credentialsService . IssueCredentialAsync ( new () { DocumentJson = credentialJson }); _testOutputHelper . WriteLine ( $\"Credential:\\n{credential.SignedDocumentJson}\" ); issue_response = await credentials_service . issue_credential ( request = IssueRequest ( document_json = credential_json ) ) The output of this method will be a signed JSON document using BBS+ Signature Suite 2020. This document is not automatically stored in the wallet when issued. You need to call the insert record separately if you'd like to store a copy of this document. Issue Credential from Template \u00b6 Trinsic CLI TypeScript C# Python Go Java Ruby import test from \"ava\" ; import { AccountService , CredentialService , WalletService , TemplateService , CreateCredentialTemplateRequest , TemplateField , FieldType , AccountProfile , IssueFromTemplateRequest , SignInRequest , InsertItemRequest , CreateProofRequest , VerifyProofRequest } from \"../src\" ; import { getTemplateCertFrameJSON , getTestServerOptions , getVaccineCertFrameJSON , getVaccineCertUnsignedJSON } from \"./TestData\" ; require ( \"dotenv\" ). config (); const options = getTestServerOptions (); // defineTemplate() { var credentialTemplateName = \"My First Credential Template\" ; var nameField = new TemplateField (); nameField . setType ( FieldType . STRING ); nameField . setDescription ( \"The name of the person\" ); nameField . setOptional ( false ); var numberOfBags = new TemplateField (); numberOfBags . setType ( FieldType . NUMBER ); numberOfBags . setDescription ( \"The number of bags the person is taking on the trip\" ); numberOfBags . setOptional ( false ); var dateOfBirth = new TemplateField (); dateOfBirth . setType ( FieldType . DATETIME ); dateOfBirth . setDescription ( \"The date of birth of the person\" ); dateOfBirth . setOptional ( false ); var isVaccinated = new TemplateField (); isVaccinated . setType ( FieldType . BOOL ); isVaccinated . setDescription ( \"Whether or not the person has been vaccinated\" ); isVaccinated . setOptional ( false ); // } let issuer = new AccountProfile (); test . before ( async t => { let service = new AccountService ( options ); let response = await service . signIn ( new SignInRequest ()); issuer . setAuthToken ( response ); }); async function createCredentialTemplateTest () { // createTemplate() { const templateService = new TemplateService ( options ); let request = new CreateCredentialTemplateRequest (); request . setName ( credentialTemplateName ); request . getFieldsMap () . set ( \"name\" , nameField ) . set ( \"numberOfBags\" , numberOfBags ) . set ( \"dateOfBirth\" , dateOfBirth ) . set ( \"vaccinated\" , isVaccinated ); let response = await templateService . createCredentialTemplate ( request ); // } return response ; } async function issueCredentialFromTemplate () { let templateResponse = await createCredentialTemplateTest (); let service = new CredentialService ( options ); // issueFromTemplate() {} let request = new IssueFromTemplateRequest () . setTemplateId ( templateResponse ? . getData () ? . getId () ?? \"\" ) . setValuesJson ( JSON . stringify ({ \"name\" : \"Alice\" , \"numberOfBags\" : 2 , \"dateOfBirth\" : new Date ( \"1/1/2000\" ). toISOString (), \"vaccinated\" : true })); let response = await service . issueFromTemplate ( request ); // } return response ; } async function verifyCredential () { const credentialService = new CredentialService ( options ); const accountService = new AccountService ( options ); const walletService = new WalletService ( options ); const allison = await accountService . signIn ( new SignInRequest ()); const airline = await accountService . signIn ( new SignInRequest ()); const credential = await issueCredentialFromTemplate (); walletService . options . setAuthToken ( allison ); const insertItemResponse = await walletService . insertItem ( new InsertItemRequest () . setItemJson ( credential . getDocumentJson ())); credentialService . options . setAuthToken ( allison ); const proofRequestJson = getTemplateCertFrameJSON (); const proofRequest = new CreateProofRequest () . setItemId ( insertItemResponse . getItemId ()) . setDocumentJson ( proofRequestJson ); const proof = await credentialService . createProof ( proofRequest ); credentialService . options . setAuthToken ( airline ); const verifyProofRequest = new VerifyProofRequest (). setProofDocumentJson ( proof . getProofDocumentJson ()) const verifyProofResponse = await credentialService . verifyProof ( verifyProofRequest ); return verifyProofResponse . getIsValid (); } test ( \"Create Credential Template\" , async ( t ) => { let response = await createCredentialTemplateTest (); t . is ( response . getData () ? . getName (), credentialTemplateName ); const fieldsMap = response . getData () ? . getFieldsMap (); t . deepEqual ( fieldsMap ? . get ( \"name\" ) ? . toObject (), nameField . toObject ()); t . deepEqual ( fieldsMap ? . get ( \"numberOfBags\" ) ? . toObject (), numberOfBags . toObject ()); t . deepEqual ( fieldsMap ? . get ( \"dateOfBirth\" ) ? . toObject (), dateOfBirth . toObject ()); t . deepEqual ( fieldsMap ? . get ( \"vaccinated\" ) ? . toObject (), isVaccinated . toObject ()); t . pass (); }); test ( \"Issue Credential From Template\" , async ( t ) => { let response = JSON . parse (( await issueCredentialFromTemplate ()). getDocumentJson ()); t . assert ( response ? . issuer !== null ); t . assert ( response ? . id !== null ); t . is ( response ? . credentialSubject ? . name , \"Alice\" ); t . is ( response ? . credentialSubject ? . numberOfBags , 2 ); t . is ( new Date ( response ? . credentialSubject ? . dateOfBirth ). toISOString (), new Date ( \"1/1/2000\" ). toISOString ()); t . is ( response ? . credentialSubject ? . vaccinated , true ); t . pass (); }) test ( \"Verify Credential Issued from Template\" , async ( t ) => { let response = await verifyCredential (); t . assert ( response ); t . pass (); }) var credentialJson = await credentialService . IssueFromTemplateAsync ( new () { TemplateId = template . Data . Id , ValuesJson = values }); values = json . dumps ({ \"firstName\" : \"Jane\" , \"lastName\" : \"Doe\" , \"age\" : 42 }) issue_response = await credential_service . issue_from_template ( request = IssueFromTemplateRequest ( template_id = template . data . id , values_json = values ) ) Check Revocation Status \u00b6 Trinsic CLI TypeScript C# Python Go Java Ruby Update Revocation Status \u00b6 Trinsic CLI TypeScript C# Python Go Java Ruby Create Proof \u00b6 Wallets allow data to be shared between parties in a secure manner, using a technique called Zero Knowledge Proofs . Trinsic Ecosystems uses the BBS+ Signature Proof scheme to allow data to be selectively disclosed to the requesting party. This allows users to share only the requested subset of data, instead the entire document. The endpoint to create a proof requires two inputs: document in the wallet that is signed with the correct signature JSONLD frame that describes the data to be disclosed Trinsic CLI TypeScript C# Python trinsic vc create-proof --document-id <STRING> --out <OUTPUT_FILE> --reveal-document <JSONLD_FRAME_FILE> let proof = await credentialService . createProof ( new CreateProofRequest () . setItemId ( insertItemResponse . getItemId ()) . setRevealDocumentJson ( JSON . stringify ( getVaccineCertFrameJSON ()))); var proof = await credentialService . CreateProofAsync ( new () { DocumentJson = credentialJson . DocumentJson , RevealDocumentJson = frame . ToString ( Formatting . None ) }); proof_response = await credentials_service . create_proof ( request = CreateProofRequest ( reveal_document_json = proof_request_json , item_id = item_id ) ) Verify Proof \u00b6 This endpoint verifies if the submitted data contains a valid proof. The data to be verified must contain a Linked Data Proof with BBS+ signature scheme. Trinsic CLI TypeScript C# Python trinsic vc issuer verify-proof --proof-document <JSONLD_FILE> let verifyResponse = await credentialService . verifyProof ( new VerifyProofRequest () . setProofDocumentJson ( proof . getProofDocumentJson ())); var valid = await credentialService . VerifyProofAsync ( new () { ProofDocumentJson = proof . ProofDocumentJson }); verify_result = await credentials_service . verify_proof ( request = VerifyProofRequest ( proof_document_json = credential_proof ) ) Exchange Credentials \u00b6 Exchanging data securely is one of the fundamental functions of digital identity systems. There are many specifications with varying maturity that aim to provide interoperable and secure way of exchanging authentic data. We are commited to providing support for these methods. DIDComm Messaging Wallet And Credential Interactions OpenID Connect Credential Provider During this beta period, we are only supporting exchanging data between users by using their email addresses. The messages are routed securely to the destination wallet without leaving the secure network of the ecosystem backend. Our goal is to provide basic ability to share data without affecting the user experience. As interoperable exchange methods become available, we will add this functionality in the SDK. Sending documents using Email as identifier \u00b6 To send a document to another user, they must have created a wallet and associated their email address with that wallet. Trinsic CLI TypeScript C# Python Go Java Ruby Swift trinsic vc send --email <EMAIL_ADDRESS> --item <FILE> await credentialService . send ( document , \"admin@example.com\" ); await credentialService . Send ( document , \"admin@example.com\" ); await credential_service . send ( document , \"admin@example.com\" );","title":"Credential Service"},{"location":"reference/services/credential-service/#credential-service","text":"","title":"Credential Service"},{"location":"reference/services/credential-service/#sdk-calls","text":"","title":"SDK Calls"},{"location":"reference/services/credential-service/#issue-credential","text":"The Credential service supports signing data using BBS+ Signatures . The data is signed with a key unique to the owner's wallet. This key is also used as linked secret, when it comes to proof derivation. This endpoint requires that the user provide a valid JSON-LD document. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic issuer issue --document <INPUT_JSONLD_FILE> --out <OUTPUT_FILE> // Sign a credential as the clinic and send it to Allison const credentialJson = getVaccineCertUnsignedJSON () const credential = await credentialService . issueCredential ( new IssueRequest () . setDocumentJson ( JSON . stringify ( credentialJson ))); var credential = await credentialsService . IssueCredentialAsync ( new () { DocumentJson = credentialJson }); _testOutputHelper . WriteLine ( $\"Credential:\\n{credential.SignedDocumentJson}\" ); issue_response = await credentials_service . issue_credential ( request = IssueRequest ( document_json = credential_json ) ) The output of this method will be a signed JSON document using BBS+ Signature Suite 2020. This document is not automatically stored in the wallet when issued. You need to call the insert record separately if you'd like to store a copy of this document.","title":"Issue Credential"},{"location":"reference/services/credential-service/#issue-credential-from-template","text":"Trinsic CLI TypeScript C# Python Go Java Ruby import test from \"ava\" ; import { AccountService , CredentialService , WalletService , TemplateService , CreateCredentialTemplateRequest , TemplateField , FieldType , AccountProfile , IssueFromTemplateRequest , SignInRequest , InsertItemRequest , CreateProofRequest , VerifyProofRequest } from \"../src\" ; import { getTemplateCertFrameJSON , getTestServerOptions , getVaccineCertFrameJSON , getVaccineCertUnsignedJSON } from \"./TestData\" ; require ( \"dotenv\" ). config (); const options = getTestServerOptions (); // defineTemplate() { var credentialTemplateName = \"My First Credential Template\" ; var nameField = new TemplateField (); nameField . setType ( FieldType . STRING ); nameField . setDescription ( \"The name of the person\" ); nameField . setOptional ( false ); var numberOfBags = new TemplateField (); numberOfBags . setType ( FieldType . NUMBER ); numberOfBags . setDescription ( \"The number of bags the person is taking on the trip\" ); numberOfBags . setOptional ( false ); var dateOfBirth = new TemplateField (); dateOfBirth . setType ( FieldType . DATETIME ); dateOfBirth . setDescription ( \"The date of birth of the person\" ); dateOfBirth . setOptional ( false ); var isVaccinated = new TemplateField (); isVaccinated . setType ( FieldType . BOOL ); isVaccinated . setDescription ( \"Whether or not the person has been vaccinated\" ); isVaccinated . setOptional ( false ); // } let issuer = new AccountProfile (); test . before ( async t => { let service = new AccountService ( options ); let response = await service . signIn ( new SignInRequest ()); issuer . setAuthToken ( response ); }); async function createCredentialTemplateTest () { // createTemplate() { const templateService = new TemplateService ( options ); let request = new CreateCredentialTemplateRequest (); request . setName ( credentialTemplateName ); request . getFieldsMap () . set ( \"name\" , nameField ) . set ( \"numberOfBags\" , numberOfBags ) . set ( \"dateOfBirth\" , dateOfBirth ) . set ( \"vaccinated\" , isVaccinated ); let response = await templateService . createCredentialTemplate ( request ); // } return response ; } async function issueCredentialFromTemplate () { let templateResponse = await createCredentialTemplateTest (); let service = new CredentialService ( options ); // issueFromTemplate() {} let request = new IssueFromTemplateRequest () . setTemplateId ( templateResponse ? . getData () ? . getId () ?? \"\" ) . setValuesJson ( JSON . stringify ({ \"name\" : \"Alice\" , \"numberOfBags\" : 2 , \"dateOfBirth\" : new Date ( \"1/1/2000\" ). toISOString (), \"vaccinated\" : true })); let response = await service . issueFromTemplate ( request ); // } return response ; } async function verifyCredential () { const credentialService = new CredentialService ( options ); const accountService = new AccountService ( options ); const walletService = new WalletService ( options ); const allison = await accountService . signIn ( new SignInRequest ()); const airline = await accountService . signIn ( new SignInRequest ()); const credential = await issueCredentialFromTemplate (); walletService . options . setAuthToken ( allison ); const insertItemResponse = await walletService . insertItem ( new InsertItemRequest () . setItemJson ( credential . getDocumentJson ())); credentialService . options . setAuthToken ( allison ); const proofRequestJson = getTemplateCertFrameJSON (); const proofRequest = new CreateProofRequest () . setItemId ( insertItemResponse . getItemId ()) . setDocumentJson ( proofRequestJson ); const proof = await credentialService . createProof ( proofRequest ); credentialService . options . setAuthToken ( airline ); const verifyProofRequest = new VerifyProofRequest (). setProofDocumentJson ( proof . getProofDocumentJson ()) const verifyProofResponse = await credentialService . verifyProof ( verifyProofRequest ); return verifyProofResponse . getIsValid (); } test ( \"Create Credential Template\" , async ( t ) => { let response = await createCredentialTemplateTest (); t . is ( response . getData () ? . getName (), credentialTemplateName ); const fieldsMap = response . getData () ? . getFieldsMap (); t . deepEqual ( fieldsMap ? . get ( \"name\" ) ? . toObject (), nameField . toObject ()); t . deepEqual ( fieldsMap ? . get ( \"numberOfBags\" ) ? . toObject (), numberOfBags . toObject ()); t . deepEqual ( fieldsMap ? . get ( \"dateOfBirth\" ) ? . toObject (), dateOfBirth . toObject ()); t . deepEqual ( fieldsMap ? . get ( \"vaccinated\" ) ? . toObject (), isVaccinated . toObject ()); t . pass (); }); test ( \"Issue Credential From Template\" , async ( t ) => { let response = JSON . parse (( await issueCredentialFromTemplate ()). getDocumentJson ()); t . assert ( response ? . issuer !== null ); t . assert ( response ? . id !== null ); t . is ( response ? . credentialSubject ? . name , \"Alice\" ); t . is ( response ? . credentialSubject ? . numberOfBags , 2 ); t . is ( new Date ( response ? . credentialSubject ? . dateOfBirth ). toISOString (), new Date ( \"1/1/2000\" ). toISOString ()); t . is ( response ? . credentialSubject ? . vaccinated , true ); t . pass (); }) test ( \"Verify Credential Issued from Template\" , async ( t ) => { let response = await verifyCredential (); t . assert ( response ); t . pass (); }) var credentialJson = await credentialService . IssueFromTemplateAsync ( new () { TemplateId = template . Data . Id , ValuesJson = values }); values = json . dumps ({ \"firstName\" : \"Jane\" , \"lastName\" : \"Doe\" , \"age\" : 42 }) issue_response = await credential_service . issue_from_template ( request = IssueFromTemplateRequest ( template_id = template . data . id , values_json = values ) )","title":"Issue Credential from Template"},{"location":"reference/services/credential-service/#check-revocation-status","text":"Trinsic CLI TypeScript C# Python Go Java Ruby","title":"Check Revocation Status"},{"location":"reference/services/credential-service/#update-revocation-status","text":"Trinsic CLI TypeScript C# Python Go Java Ruby","title":"Update Revocation Status"},{"location":"reference/services/credential-service/#create-proof","text":"Wallets allow data to be shared between parties in a secure manner, using a technique called Zero Knowledge Proofs . Trinsic Ecosystems uses the BBS+ Signature Proof scheme to allow data to be selectively disclosed to the requesting party. This allows users to share only the requested subset of data, instead the entire document. The endpoint to create a proof requires two inputs: document in the wallet that is signed with the correct signature JSONLD frame that describes the data to be disclosed Trinsic CLI TypeScript C# Python trinsic vc create-proof --document-id <STRING> --out <OUTPUT_FILE> --reveal-document <JSONLD_FRAME_FILE> let proof = await credentialService . createProof ( new CreateProofRequest () . setItemId ( insertItemResponse . getItemId ()) . setRevealDocumentJson ( JSON . stringify ( getVaccineCertFrameJSON ()))); var proof = await credentialService . CreateProofAsync ( new () { DocumentJson = credentialJson . DocumentJson , RevealDocumentJson = frame . ToString ( Formatting . None ) }); proof_response = await credentials_service . create_proof ( request = CreateProofRequest ( reveal_document_json = proof_request_json , item_id = item_id ) )","title":"Create Proof"},{"location":"reference/services/credential-service/#verify-proof","text":"This endpoint verifies if the submitted data contains a valid proof. The data to be verified must contain a Linked Data Proof with BBS+ signature scheme. Trinsic CLI TypeScript C# Python trinsic vc issuer verify-proof --proof-document <JSONLD_FILE> let verifyResponse = await credentialService . verifyProof ( new VerifyProofRequest () . setProofDocumentJson ( proof . getProofDocumentJson ())); var valid = await credentialService . VerifyProofAsync ( new () { ProofDocumentJson = proof . ProofDocumentJson }); verify_result = await credentials_service . verify_proof ( request = VerifyProofRequest ( proof_document_json = credential_proof ) )","title":"Verify Proof"},{"location":"reference/services/credential-service/#exchange-credentials","text":"Exchanging data securely is one of the fundamental functions of digital identity systems. There are many specifications with varying maturity that aim to provide interoperable and secure way of exchanging authentic data. We are commited to providing support for these methods. DIDComm Messaging Wallet And Credential Interactions OpenID Connect Credential Provider During this beta period, we are only supporting exchanging data between users by using their email addresses. The messages are routed securely to the destination wallet without leaving the secure network of the ecosystem backend. Our goal is to provide basic ability to share data without affecting the user experience. As interoperable exchange methods become available, we will add this functionality in the SDK.","title":"Exchange Credentials"},{"location":"reference/services/provider-service/","text":"Provider Service \u00b6 This service helps ecosystem providers with data management and onboarding. This service requires a security profile with administrative authorization access. This can be obtained during the deployment of your ecosystem infrastructure. Onboarding \u00b6 Invite Participant \u00b6 Users can be onboarded as participants in the ecosystem by sending an invitation and a security code. This code can be sent directly through them using existing platforms or via email, SMS, etc. When users accept this invitation, they should do so using the service methods as described in creating wallet with provider invitation In Trinsic Ecosystems, participants can be Individuals or Organizations. This distinction is important, as providers have the ability to apply restrictions on what functionalities can be invoked by these participants. Additionally, Organizations have the ability to write their DID Document to a public ledger. Currently, the supported ledger is Sovrin, with ION and Element still in development. Trinsic CLI TypeScript C# Python trinsic provider invite --organization --method-email admin@faber.edu trinsic provider invite --person --method-email alice@faber.edu import { ProviderService , ParticipantType } from \"@trinsic/trinsic\" ; const providerService = new ProviderService (); let inviteRequest = new InviteRequest (); inviteRequest . setParticipant ( ParticipantType . PARTICIPANT_TYPE_ORGANIZATION ); inviteRequest . setEmail ( \"admin@faber.edu\" ); const inviteResponse = await providerService . inviteParticipant ( inviteRequest ); console . log ( inviteResponse . getInvitationId ()); using Trinsic ; var providerService = new ProviderService (); var inviteRequest = new InviteRequest { ParticipantType = ParticipantType . Organization , Email = \"admin@faber.edu\" } let inviteResponse = await providerService . InviteParticipant ( inviteRequest ); Console . WriteLine ( inviteResponse . InvitationId ); from trinsic.services import ProviderService request = { \"email\" : \"admin@faber.edu\" , \"participant\" : provider_services . Organization } response = await provider_service . invite_participant ( request ) The invitationId in the response contains the security code that users must supply when creating their wallet. If using email method in onboarding, they will receive this code in their email. ParticipantType Check Invitation Status \u00b6 User invitation status can be checked with the provided invitation id . It returns an InvitationStatusResponse object. Invitation Status Request Invitation Status Response Trinsic CLI TypeScript C# Python trinsic provider invitation_status <INVITATION_ID> import { ProviderService , ParticipantType } from \"@trinsic/trinsic\" ; const providerService = new ProviderService (); const inviteResponse = await providerService . invitationStatus ( \"INVITATION ID\" ); console . log ( inviteResponse . getInvitationId ()); using Trinsic ; var providerService = new ProviderService (); let invitationStatus = await providerService . InvitationStatus ( \"INVITATION ID\" ); from trinsic.services import ProviderService response = await provider_service . invitation_status ( invitation_id = \"INVITATION ID\" ) The invitationId in the response contains the security code that users must supply when creating their wallet. If using email method in onboarding, they will receive this code in their email.","title":"Provider Service"},{"location":"reference/services/provider-service/#provider-service","text":"This service helps ecosystem providers with data management and onboarding. This service requires a security profile with administrative authorization access. This can be obtained during the deployment of your ecosystem infrastructure.","title":"Provider Service"},{"location":"reference/services/provider-service/#onboarding","text":"","title":"Onboarding"},{"location":"reference/services/provider-service/#invite-participant","text":"Users can be onboarded as participants in the ecosystem by sending an invitation and a security code. This code can be sent directly through them using existing platforms or via email, SMS, etc. When users accept this invitation, they should do so using the service methods as described in creating wallet with provider invitation In Trinsic Ecosystems, participants can be Individuals or Organizations. This distinction is important, as providers have the ability to apply restrictions on what functionalities can be invoked by these participants. Additionally, Organizations have the ability to write their DID Document to a public ledger. Currently, the supported ledger is Sovrin, with ION and Element still in development. Trinsic CLI TypeScript C# Python trinsic provider invite --organization --method-email admin@faber.edu trinsic provider invite --person --method-email alice@faber.edu import { ProviderService , ParticipantType } from \"@trinsic/trinsic\" ; const providerService = new ProviderService (); let inviteRequest = new InviteRequest (); inviteRequest . setParticipant ( ParticipantType . PARTICIPANT_TYPE_ORGANIZATION ); inviteRequest . setEmail ( \"admin@faber.edu\" ); const inviteResponse = await providerService . inviteParticipant ( inviteRequest ); console . log ( inviteResponse . getInvitationId ()); using Trinsic ; var providerService = new ProviderService (); var inviteRequest = new InviteRequest { ParticipantType = ParticipantType . Organization , Email = \"admin@faber.edu\" } let inviteResponse = await providerService . InviteParticipant ( inviteRequest ); Console . WriteLine ( inviteResponse . InvitationId ); from trinsic.services import ProviderService request = { \"email\" : \"admin@faber.edu\" , \"participant\" : provider_services . Organization } response = await provider_service . invite_participant ( request ) The invitationId in the response contains the security code that users must supply when creating their wallet. If using email method in onboarding, they will receive this code in their email. ParticipantType","title":"Invite Participant"},{"location":"reference/services/provider-service/#check-invitation-status","text":"User invitation status can be checked with the provided invitation id . It returns an InvitationStatusResponse object. Invitation Status Request Invitation Status Response Trinsic CLI TypeScript C# Python trinsic provider invitation_status <INVITATION_ID> import { ProviderService , ParticipantType } from \"@trinsic/trinsic\" ; const providerService = new ProviderService (); const inviteResponse = await providerService . invitationStatus ( \"INVITATION ID\" ); console . log ( inviteResponse . getInvitationId ()); using Trinsic ; var providerService = new ProviderService (); let invitationStatus = await providerService . InvitationStatus ( \"INVITATION ID\" ); from trinsic.services import ProviderService response = await provider_service . invitation_status ( invitation_id = \"INVITATION ID\" ) The invitationId in the response contains the security code that users must supply when creating their wallet. If using email method in onboarding, they will receive this code in their email.","title":"Check Invitation Status"},{"location":"reference/services/template-service/","text":"Credential Templates \u00b6 Credential Templates are json templates that help issuers save context when issuing credentials. When issuing a credential through Trinsic, it's as simple as adding the attributes to the credential template and then issuing it. These credential templates can be shared between issuers in an ecosystem. A template is a saved JSON-LD schema that is used to define/create credentials and verification. Create Credential Template \u00b6 Trinsic CLI TypeScript C# Python Go Java Ruby var credentialTemplateName = \"My First Credential Template\" ; var nameField = new TemplateField (); nameField . setType ( FieldType . STRING ); nameField . setDescription ( \"The name of the person\" ); nameField . setOptional ( false ); var numberOfBags = new TemplateField (); numberOfBags . setType ( FieldType . NUMBER ); numberOfBags . setDescription ( \"The number of bags the person is taking on the trip\" ); numberOfBags . setOptional ( false ); var dateOfBirth = new TemplateField (); dateOfBirth . setType ( FieldType . DATETIME ); dateOfBirth . setDescription ( \"The date of birth of the person\" ); dateOfBirth . setOptional ( false ); var isVaccinated = new TemplateField (); isVaccinated . setType ( FieldType . BOOL ); isVaccinated . setDescription ( \"Whether or not the person has been vaccinated\" ); isVaccinated . setOptional ( false ); CreateCredentialTemplateRequest templateRequest = new () { Name = \"An Example Credential\" , AllowAdditionalFields = false }; templateRequest . Fields . Add ( \"firstName\" , new () { Description = \"Given name\" }); templateRequest . Fields . Add ( \"lastName\" , new ()); templateRequest . Fields . Add ( \"age\" , new () { Type = FieldType . Number , Optional = true }); var template = await templateService . CreateAsync ( templateRequest ); template = await template_service . create ( request = CreateCredentialTemplateRequest ( name = \"An Example Credential\" , allow_additional_fields = False , fields = { \"firstName\" : TemplateField ( description = \"Given name\" ), \"lastName\" : TemplateField (), \"age\" : TemplateField ( type = FieldType . NUMBER , optional = True ), }, ) ) Get \u00b6 Trinsic CLI TypeScript C# Python Go Java Ruby Search \u00b6 Trinsic CLI TypeScript C# Python Go Java Ruby Update \u00b6 Trinsic CLI TypeScript C# Python Go Java Ruby Delete \u00b6 Trinsic CLI TypeScript C# Python Go Java","title":"Credential Templates"},{"location":"reference/services/template-service/#credential-templates","text":"Credential Templates are json templates that help issuers save context when issuing credentials. When issuing a credential through Trinsic, it's as simple as adding the attributes to the credential template and then issuing it. These credential templates can be shared between issuers in an ecosystem. A template is a saved JSON-LD schema that is used to define/create credentials and verification.","title":"Credential Templates"},{"location":"reference/services/template-service/#create-credential-template","text":"Trinsic CLI TypeScript C# Python Go Java Ruby var credentialTemplateName = \"My First Credential Template\" ; var nameField = new TemplateField (); nameField . setType ( FieldType . STRING ); nameField . setDescription ( \"The name of the person\" ); nameField . setOptional ( false ); var numberOfBags = new TemplateField (); numberOfBags . setType ( FieldType . NUMBER ); numberOfBags . setDescription ( \"The number of bags the person is taking on the trip\" ); numberOfBags . setOptional ( false ); var dateOfBirth = new TemplateField (); dateOfBirth . setType ( FieldType . DATETIME ); dateOfBirth . setDescription ( \"The date of birth of the person\" ); dateOfBirth . setOptional ( false ); var isVaccinated = new TemplateField (); isVaccinated . setType ( FieldType . BOOL ); isVaccinated . setDescription ( \"Whether or not the person has been vaccinated\" ); isVaccinated . setOptional ( false ); CreateCredentialTemplateRequest templateRequest = new () { Name = \"An Example Credential\" , AllowAdditionalFields = false }; templateRequest . Fields . Add ( \"firstName\" , new () { Description = \"Given name\" }); templateRequest . Fields . Add ( \"lastName\" , new ()); templateRequest . Fields . Add ( \"age\" , new () { Type = FieldType . Number , Optional = true }); var template = await templateService . CreateAsync ( templateRequest ); template = await template_service . create ( request = CreateCredentialTemplateRequest ( name = \"An Example Credential\" , allow_additional_fields = False , fields = { \"firstName\" : TemplateField ( description = \"Given name\" ), \"lastName\" : TemplateField (), \"age\" : TemplateField ( type = FieldType . NUMBER , optional = True ), }, ) )","title":"Create Credential Template"},{"location":"reference/services/template-service/#get","text":"Trinsic CLI TypeScript C# Python Go Java Ruby","title":"Get"},{"location":"reference/services/template-service/#search","text":"Trinsic CLI TypeScript C# Python Go Java Ruby","title":"Search"},{"location":"reference/services/template-service/#update","text":"Trinsic CLI TypeScript C# Python Go Java Ruby","title":"Update"},{"location":"reference/services/template-service/#delete","text":"Trinsic CLI TypeScript C# Python Go Java","title":"Delete"},{"location":"reference/services/trust-registry-service/","text":"Trust Registry \u00b6 In many real-world credential exchange scenarios, a credential holder or verifier has the question \u201cHow do I know the issuer of this credential is trustworthy?\u201d Credential holders may also be uneasy about sharing information with a verifier if trust in the verifier has not been established. These problems can be solved by having a trusted third party vouch for the trustworthiness of a credential exchange participant. A trust registry is a list of authorized issuers and verifiers in the ecosystem and the types of credentials and passes they are authorized to issue and verify. Specification \u00b6 The Trust over IP Foundation has a specification for a interoperable trust registry. This defined an API interface so that trust registries can be queried in the same way. Our implementation is based off of this trust registry spec . API Reference \u00b6 Create a Ecosystem Governance Framework \u00b6 An ecosystem governance framework is useful because it provides a good basis for verifying issuers and verifiers. It's a json-ld document that lists the issuers and verifiers. These issuers and verifiers are identified by a decentralized identifier. The governance framework is signified by an identifier as well. This can be used to represent the governance framework outside in the credential that it comes in. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry register-efg Register Issuers and Verifiers \u00b6 Each entity on the governance framework, whether an issuer or a verifier, is represented by a decentralized identifier. These entities are registered to either issue or verify specific credential types. A credential type is represented as a fully qualified type URI, of the kind found in a JSON-LD Verifiable Credential. Finally, each entity must be registered on a specific governance framework. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry register-issuer \\ --egf http://hl7.org/fhir \\ --credential-type https://w3id.org/vaccination#VaccinationCertificate \\ --did did:example:fabre Unregister Issuers and Verifiers \u00b6 To unregister an entity, include the credential type, the did, and the ecosystem governance framework. The credential type will be unregistered from that issuer. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry unregister-issuer \\ --egf http://hl7.org/fhir \\ --credential-type https://w3id.org/vaccination#VaccinationCertificate \\ --did did:example:fabre Check Authoritative Status \u00b6 Check the status of an issuer for a credential type within a given governance framework. Returns all historical data for the given input parameter. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry check-issuer \\ --egf http://hl7.org/fhir \\ --credential-type https://w3id.org/vaccination#VaccinationCertificate \\ --did did:example:fabre Search \u00b6 Search the registry for authoritative issuer and verifiers using a custom query in a SQL format. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry search --query <SQL query> Cache Offline Registry File \u00b6 Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry download","title":"Trust Registry Service"},{"location":"reference/services/trust-registry-service/#trust-registry","text":"In many real-world credential exchange scenarios, a credential holder or verifier has the question \u201cHow do I know the issuer of this credential is trustworthy?\u201d Credential holders may also be uneasy about sharing information with a verifier if trust in the verifier has not been established. These problems can be solved by having a trusted third party vouch for the trustworthiness of a credential exchange participant. A trust registry is a list of authorized issuers and verifiers in the ecosystem and the types of credentials and passes they are authorized to issue and verify.","title":"Trust Registry"},{"location":"reference/services/trust-registry-service/#specification","text":"The Trust over IP Foundation has a specification for a interoperable trust registry. This defined an API interface so that trust registries can be queried in the same way. Our implementation is based off of this trust registry spec .","title":"Specification"},{"location":"reference/services/trust-registry-service/#api-reference","text":"","title":"API Reference"},{"location":"reference/services/trust-registry-service/#create-a-ecosystem-governance-framework","text":"An ecosystem governance framework is useful because it provides a good basis for verifying issuers and verifiers. It's a json-ld document that lists the issuers and verifiers. These issuers and verifiers are identified by a decentralized identifier. The governance framework is signified by an identifier as well. This can be used to represent the governance framework outside in the credential that it comes in. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry register-efg","title":"Create a Ecosystem Governance Framework"},{"location":"reference/services/trust-registry-service/#register-issuers-and-verifiers","text":"Each entity on the governance framework, whether an issuer or a verifier, is represented by a decentralized identifier. These entities are registered to either issue or verify specific credential types. A credential type is represented as a fully qualified type URI, of the kind found in a JSON-LD Verifiable Credential. Finally, each entity must be registered on a specific governance framework. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry register-issuer \\ --egf http://hl7.org/fhir \\ --credential-type https://w3id.org/vaccination#VaccinationCertificate \\ --did did:example:fabre","title":"Register Issuers and Verifiers"},{"location":"reference/services/trust-registry-service/#unregister-issuers-and-verifiers","text":"To unregister an entity, include the credential type, the did, and the ecosystem governance framework. The credential type will be unregistered from that issuer. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry unregister-issuer \\ --egf http://hl7.org/fhir \\ --credential-type https://w3id.org/vaccination#VaccinationCertificate \\ --did did:example:fabre","title":"Unregister Issuers and Verifiers"},{"location":"reference/services/trust-registry-service/#check-authoritative-status","text":"Check the status of an issuer for a credential type within a given governance framework. Returns all historical data for the given input parameter. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry check-issuer \\ --egf http://hl7.org/fhir \\ --credential-type https://w3id.org/vaccination#VaccinationCertificate \\ --did did:example:fabre","title":"Check Authoritative Status"},{"location":"reference/services/trust-registry-service/#search","text":"Search the registry for authoritative issuer and verifiers using a custom query in a SQL format. Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry search --query <SQL query>","title":"Search"},{"location":"reference/services/trust-registry-service/#cache-offline-registry-file","text":"Trinsic CLI TypeScript C# Python Go Java Ruby trinsic trust-registry download","title":"Cache Offline Registry File"},{"location":"reference/services/wallet-service/","text":"Wallet Service \u00b6 The wallet service is the main interface for interacting with a cloud wallet. The service endpoints are designed to closely match the recommendations of the Universal Wallet 2020 specification by W3C Community Credentials Group. The service exposes a gRPC interface and a set of data contracts as described in the specification. Our intention with this design is to bring it closer to interoperability as more implementations of this wallet appear in production. Create Wallet \u00b6 Wallets can be created directly by the user or through an invitation by the ecosystem provider. Depending on the ecosystem settings, direct wallet creation may not be enabled for your provider. The wallet is created automatically upon user signin. Insert Item \u00b6 This method allows inserting any JSON data in the wallet. Trinsic CLI TypeScript trinsic wallet insert-item --item <INPUT_JSON_FILE> let insertItemResponse = await walletService . insertItem ( new InsertItemRequest () . setItemJson ( issueResponse . getSignedDocumentJson ())); C# var insertItemResponse = await walletService . InsertItemAsync ( new () { ItemJson = credentialJson . DocumentJson }); Python insert_response = await wallet_service . insert_item ( request = InsertItemRequest ( item_json = credential ) ) The output of this method will be a unique itemId that can be used as input where required. Search / Query \u00b6 Querying wallet data in our SDK is enabled through the use of familiar SQL syntax. All data is stored in JSON-LD format, so it can be easily searched. This apporach allows us to give developers full control over how data is retrieved. In addition to customizable sorting, paging and filtering, developers have the ability to construct projections, combine result sets, and even run user-defined functions over their queries. This endpoint will support querying using Verifiable Presentation Request Spec . This feature is still in development. Basic Search \u00b6 The default query used in the commands below returns a full wallet result set. The query is SELECT * FROM c . Trinsic CLI TypeScript C# Python trinsic wallet search let items = await walletService . search (); \u22ef let items2 = await walletService . search ( new SearchRequest (). setQuery ( \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" )); var walletItems = await walletService . SearchAsync ( new ()); \u22ef var walletItems2 = await walletService . SearchAsync ( new () { Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" }) wallet_items = await wallet_service . search () \u22ef wallet_items2 = await wallet_service . search ( request = SearchRequest ( query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" )) SQL Search \u00b6 To pass custom query to the search function, use the query parameter or the available overload. Trinsic CLI TypeScript C# Python trinsic wallet search \\ --query \"SELECT * FROM c WHERE c.type = 'VerifiableCredential'\" let items2 = await walletService . search ( new SearchRequest (). setQuery ( \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" )); var walletItems2 = await walletService . SearchAsync ( new () { Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" }) wallet_items2 = await wallet_service . search ( request = SearchRequest ( query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" )) Common SQL Queries \u00b6 Paging \u00b6 Paging uses the OFFSET clause that takes in a value indicating how many records should be skipped in the returned query. To specify the size of the result set (page size) use the LIMIT clause. SELECT * FROM c OFFSET 10 LIMIT 5 Sorting \u00b6 The optional ORDER BY clause specifies the sorting order for results returned by the query. To control sorting order, specify ASC or DESC at the end; if not specified ascending order is used by default. SELECT * FROM c ORDER BY c . credential . issued DESC Filtering \u00b6 The optional WHERE clause ( WHERE <filter_condition> ) specifies condition(s) that the source JSON items must satisfy for the query to include them in results. A JSON item must evaluate the specified conditions to true to be considered for the result. The index layer uses the WHERE clause to determine the smallest subset of source items that can be part of the result. SELECT * FROM c WHERE c . name = 'Trinsic' AND c . dateCreated >= \"2020-09-30T23:14:25.7251173Z\" Grouping \u00b6 The GROUP BY clause divides the query's results according to the values of one or more specified properties. Examples and detailed description on working with grouped results can be found here Additional Resources \u00b6 You can read the full documentation on working with SQL queries on the Azure Cosmos DB website .","title":"Wallet Service"},{"location":"reference/services/wallet-service/#wallet-service","text":"The wallet service is the main interface for interacting with a cloud wallet. The service endpoints are designed to closely match the recommendations of the Universal Wallet 2020 specification by W3C Community Credentials Group. The service exposes a gRPC interface and a set of data contracts as described in the specification. Our intention with this design is to bring it closer to interoperability as more implementations of this wallet appear in production.","title":"Wallet Service"},{"location":"reference/services/wallet-service/#create-wallet","text":"Wallets can be created directly by the user or through an invitation by the ecosystem provider. Depending on the ecosystem settings, direct wallet creation may not be enabled for your provider. The wallet is created automatically upon user signin.","title":"Create Wallet"},{"location":"reference/services/wallet-service/#insert-item","text":"This method allows inserting any JSON data in the wallet. Trinsic CLI TypeScript trinsic wallet insert-item --item <INPUT_JSON_FILE> let insertItemResponse = await walletService . insertItem ( new InsertItemRequest () . setItemJson ( issueResponse . getSignedDocumentJson ())); C# var insertItemResponse = await walletService . InsertItemAsync ( new () { ItemJson = credentialJson . DocumentJson }); Python insert_response = await wallet_service . insert_item ( request = InsertItemRequest ( item_json = credential ) ) The output of this method will be a unique itemId that can be used as input where required.","title":"Insert Item"},{"location":"reference/services/wallet-service/#search-query","text":"Querying wallet data in our SDK is enabled through the use of familiar SQL syntax. All data is stored in JSON-LD format, so it can be easily searched. This apporach allows us to give developers full control over how data is retrieved. In addition to customizable sorting, paging and filtering, developers have the ability to construct projections, combine result sets, and even run user-defined functions over their queries. This endpoint will support querying using Verifiable Presentation Request Spec . This feature is still in development.","title":"Search / Query"},{"location":"reference/services/wallet-service/#basic-search","text":"The default query used in the commands below returns a full wallet result set. The query is SELECT * FROM c . Trinsic CLI TypeScript C# Python trinsic wallet search let items = await walletService . search (); \u22ef let items2 = await walletService . search ( new SearchRequest (). setQuery ( \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" )); var walletItems = await walletService . SearchAsync ( new ()); \u22ef var walletItems2 = await walletService . SearchAsync ( new () { Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" }) wallet_items = await wallet_service . search () \u22ef wallet_items2 = await wallet_service . search ( request = SearchRequest ( query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" ))","title":"Basic Search"},{"location":"reference/services/wallet-service/#sql-search","text":"To pass custom query to the search function, use the query parameter or the available overload. Trinsic CLI TypeScript C# Python trinsic wallet search \\ --query \"SELECT * FROM c WHERE c.type = 'VerifiableCredential'\" let items2 = await walletService . search ( new SearchRequest (). setQuery ( \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" )); var walletItems2 = await walletService . SearchAsync ( new () { Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" }) wallet_items2 = await wallet_service . search ( request = SearchRequest ( query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" ))","title":"SQL Search"},{"location":"reference/services/wallet-service/#common-sql-queries","text":"","title":"Common SQL Queries"},{"location":"reference/services/wallet-service/#additional-resources","text":"You can read the full documentation on working with SQL queries on the Azure Cosmos DB website .","title":"Additional Resources"},{"location":"ruby/","text":"The Trinsic Ruby SDK \u00b6 The Trinsic Ruby SDK makes it easy to interact with the Trinsic API from any Ruby application. The most recent version of the library can be found on RubyGems . You can find the SDKs source on Github . Installation and Configuration \u00b6 Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here If you install to a different location for debugging, use the environment variable RUBY_DLL_PATH on windows. LD_LIBRARY_PATH for Ruby on Mac/Linux gem install trinsic-services Test installation by running the following Ruby script: require 'trinsic_services' account_service = Trinsic :: AccountService . new ( nil , Trinsic :: trinsic_prod_server ) account_profile = account_service . sign_in ( nil ) . profile puts account_profile Output should look something like this: < Services :: Account :: V1 :: AccountProfile : profile_type : \"https://trinsic.id/security/v1/oberon\" , auth_data : \")urn:trinsic:wallets:bbBEp9EmV1NNWMadBhit2$19ac25ae-2fd0-44d1-9ef7-73cc668e8f7d\" , auth_token : \"\u2592\" , protection : < Services :: Account :: V1 :: TokenProtection : enabled : false , method : :None >> Next Steps \u00b6 Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API","title":"Ruby"},{"location":"ruby/#the-trinsic-ruby-sdk","text":"The Trinsic Ruby SDK makes it easy to interact with the Trinsic API from any Ruby application. The most recent version of the library can be found on RubyGems . You can find the SDKs source on Github .","title":"The Trinsic Ruby SDK"},{"location":"ruby/#installation-and-configuration","text":"Make sure you have the okapi native binaries installed on your machine. Default installation instructions are in the readme.md here If you install to a different location for debugging, use the environment variable RUBY_DLL_PATH on windows. LD_LIBRARY_PATH for Ruby on Mac/Linux gem install trinsic-services Test installation by running the following Ruby script: require 'trinsic_services' account_service = Trinsic :: AccountService . new ( nil , Trinsic :: trinsic_prod_server ) account_profile = account_service . sign_in ( nil ) . profile puts account_profile Output should look something like this: < Services :: Account :: V1 :: AccountProfile : profile_type : \"https://trinsic.id/security/v1/oberon\" , auth_data : \")urn:trinsic:wallets:bbBEp9EmV1NNWMadBhit2$19ac25ae-2fd0-44d1-9ef7-73cc668e8f7d\" , auth_token : \"\u2592\" , protection : < Services :: Account :: V1 :: TokenProtection : enabled : false , method : :None >>","title":"Installation and Configuration"},{"location":"ruby/#next-steps","text":"Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API","title":"Next Steps"},{"location":"walkthroughs/vaccination/","text":"Walkthrough \u00b6 This walkthrough will show how a vaccination card can be issued, held, and proven using verifiable credentials with the Trinsic CLI. Feel free to follow along in a terminal using the CLI. We'll cover each part of Trinsic's platform during the tutorial. Meet Allison \u00b6 In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Verifier : Verifies passes presented from holders. In this case, Allison will be the holder, a vaccination clinic will be an issuer, and an airline will be the verifier. walkthrough |- allison - Holder |- clinic - Issuer |- airline - Verifier Our SDKs \u00b6 This tutorial is meant to share the concepts of verifiable credentials. So feel free to sit back and read through this without running any code. However, you can also follow along using one of our SDKs. We've set up some environments to use on Repl.it. If your language of choice isn't supported on repl.it, you can also run locally by installing the SDK of your choice. Trinsic CLI TypeScript C# Python Java Ruby Go Installation instructions for the Trinsic CLI. Once the CLI is installed, clone our CLI example repository on Github to download the credential data for this walkthrough. git clone https://github.com/trinsic-id/cli-example && cd cli-example If you don't want to install locally, we also have a replit environment for you to use. In a new tab, you can open our to use the CLI. This demo environment works best when run side-by-side the following walkthrough using two tabs in your browser. Installation instructions for the Node SDK. Installation instructions for the Browser SDk. Let's create a new .NET console app that we will use to add our sample code dotnet new console -n TrinsicSample && cd TrinsicSample Now we'll follow the installation instructions for Dotnet. Installation instructions for Python. Installation instructions for Java. In this project, we'll be following along the java/src/test/java/trinsic/VaccineDemo.java in our SDK repository Install Instructions Install Instructions Creating Accounts \u00b6 We'll start by creating a Trinsic Wallet for each participant in this credential exchange. Wallets can be created by anyone, for anyone. In this scenario, we'll have three wallets. Allison will be the credential holder, the Airline will be the verifier, and the vaccination clinic will be the issuer. When a new Trinsic account is created, a cloud wallet is created on our platform and an authentication key is generated by our SDK locally. Each person is the sole owner of their cloud wallet. They're meant to be easy to create so that you can create a cloud wallet for an end-user in your UX with very little friction. Trinsic CLI Typescript C# Python Java Go The CLI offers an interactive way of creating wallets. For demo purposes, we'll create all three on the same machine. However, this demo could be done with all three wallets created on three separate machines. When creating a wallet in the CLI, the wallet will store a private authentication token for the wallet in ~/.trinsic. If using the CLI with a real-world wallet, store this authentication token somewhere securely. trinsic account login --description \"Allison's Wallet\" --alias allison && \\ trinsic account login --description \"Airline's wallet\" --alias airline && \\ trinsic account login --description \"Vaccination Clinic\" --alias clinic // Create 3 different profiles for each participant in the scenario const allison = await accountService . signIn ( new SignInRequest ()); const clinic = await accountService . signIn ( new SignInRequest ()); const airline = await accountService . signIn ( new SignInRequest ()); var allison = await accountService . SignInAsync ( new () { EcosystemId = ecosystemId }); var clinic = await accountService . SignInAsync ( new () { EcosystemId = ecosystemId }); var airline = await accountService . SignInAsync ( new () { EcosystemId = ecosystemId }); # Create 3 different profiles for each participant in the scenario allison = await account_service . sign_in ( request = SignInRequest ( ecosystem_id = ecosystem_id ) ) clinic = await account_service . sign_in ( request = SignInRequest ( ecosystem_id = ecosystem_id ) ) airline = await account_service . sign_in ( request = SignInRequest ( ecosystem_id = ecosystem_id ) ) // Create 3 different profiles for each participant in the scenario var allison = accountService . signIn (). get (); var clinic = accountService . signIn (). get (); var airline = accountService . signIn (). get (); allison , _ , err := accountService . SignIn ( context . Background (), & sdk . SignInRequest {}) failError ( t , \"error creating profile\" , err ) if ! assert2 . NotNil ( allison ) { return } clinic , _ , err := accountService . SignIn ( context . Background (), & sdk . SignInRequest {}) failError ( t , \"error creating profile\" , err ) if ! assert2 . NotNil ( clinic ) { return } airline , _ , err := accountService . SignIn ( context . Background (), & sdk . SignInRequest {}) failError ( t , \"error creating profile\" , err ) if ! assert2 . NotNil ( airline ) { return } If you would like to save the profile for future use, you can simply export the serialized profile to a local storage. Please note that the profiles contain sensitive key data, so they should be stored in a secure enclave. C# Python Java Go // Serialize auth token by exporting it to file File . WriteAllText ( \"allison.txt\" , allison ); // Create auth token from existing data allison = File . ReadAllText ( \"allison.txt\" ); # Store profile for later use with open ( \"allison.txt\" , \"wb\" ) as fid : fid . write ( allison . encode ( \"utf-8\" )) # Create profile from existing data with open ( \"allison.txt\" , \"rb\" ) as fid : allison = fid . readline () var writeFile = new BufferedWriter ( new FileWriter ( \"allison.txt\" )); writeFile . write ( allison ); writeFile . flush (); writeFile . close (); // Create profile from existing data var readFile = new BufferedReader ( new FileReader ( \"allison.txt\" )); allison = readFile . readLine (). strip (); readFile . close (); // Store profile for later use // File.WriteAllBytes(\"allison.bin\", allison.ToByteString().ToByteArray()); // Create profile from existing data // var allison = WalletProfile.Parser.ParseFrom(File.ReadAllBytes(\"allison.bin\")); Note References: Manage access to cloud wallets with the Account Service Learn more about Wallets Read more about security profiles and authentication. Define a Template \u00b6 Trinsic CLI Typescript C# Python Java var credentialTemplateName = \"My First Credential Template\" ; var nameField = new TemplateField (); nameField . setType ( FieldType . STRING ); nameField . setDescription ( \"The name of the person\" ); nameField . setOptional ( false ); var numberOfBags = new TemplateField (); numberOfBags . setType ( FieldType . NUMBER ); numberOfBags . setDescription ( \"The number of bags the person is taking on the trip\" ); numberOfBags . setOptional ( false ); var dateOfBirth = new TemplateField (); dateOfBirth . setType ( FieldType . DATETIME ); dateOfBirth . setDescription ( \"The date of birth of the person\" ); dateOfBirth . setOptional ( false ); var isVaccinated = new TemplateField (); isVaccinated . setType ( FieldType . BOOL ); isVaccinated . setDescription ( \"Whether or not the person has been vaccinated\" ); isVaccinated . setOptional ( false ); const templateService = new TemplateService ( options ); let request = new CreateCredentialTemplateRequest (); request . setName ( credentialTemplateName ); request . getFieldsMap () . set ( \"name\" , nameField ) . set ( \"numberOfBags\" , numberOfBags ) . set ( \"dateOfBirth\" , dateOfBirth ) . set ( \"vaccinated\" , isVaccinated ); let response = await templateService . createCredentialTemplate ( request ); CreateCredentialTemplateRequest templateRequest = new () { Name = \"An Example Credential\" , AllowAdditionalFields = false }; templateRequest . Fields . Add ( \"firstName\" , new () { Description = \"Given name\" }); templateRequest . Fields . Add ( \"lastName\" , new ()); templateRequest . Fields . Add ( \"age\" , new () { Type = FieldType . Number , Optional = true }); var template = await templateService . CreateAsync ( templateRequest ); template = await template_service . create ( request = CreateCredentialTemplateRequest ( name = \"An Example Credential\" , allow_additional_fields = False , fields = { \"firstName\" : TemplateField ( description = \"Given name\" ), \"lastName\" : TemplateField (), \"age\" : TemplateField ( type = FieldType . NUMBER , optional = True ), }, ) ) package trinsic ; import com.google.gson.Gson ; import trinsic.okapi.DidException ; import trinsic.services.AccountService ; import trinsic.services.CredentialTemplateService ; import trinsic.services.CredentialsService ; import trinsic.services.verifiablecredentials.templates.v1.Templates ; import trinsic.services.verifiablecredentials.v1.VerifiableCredentials ; import java.io.IOException ; import java.util.HashMap ; import java.util.concurrent.ExecutionException ; public class TemplatesDemo { public static void main ( String [] args ) throws IOException , DidException , ExecutionException , InterruptedException { run (); } public static void run () throws IOException , DidException , ExecutionException , InterruptedException { var accountService = new AccountService ( TrinsicUtilities . getTrinsicServiceOptions ()); var account = accountService . signIn (). get (); var templateService = new CredentialTemplateService ( TrinsicUtilities . getTrinsicServiceOptions ( account )); var credentialService = new CredentialsService ( TrinsicUtilities . getTrinsicServiceOptions ( account )); // create example template var fields = new HashMap < String , Templates . TemplateField > (); fields . put ( \"firstName\" , Templates . TemplateField . newBuilder (). setDescription ( \"Given name\" ). build ()); fields . put ( \"lastName\" , Templates . TemplateField . newBuilder (). build ()); fields . put ( \"age\" , Templates . TemplateField . newBuilder (). setType ( Templates . FieldType . NUMBER ). setOptional ( true ). build ()); var templateRequest = Templates . CreateCredentialTemplateRequest . newBuilder (). setName ( \"My Example Credential\" ). setAllowAdditionalFields ( false ). putAllFields ( fields ). build (); var template = templateService . create ( templateRequest ). get (); assert template != null ; assert template . hasData (); assert ! template . getData (). getId (). isEmpty (); assert ! template . getData (). getSchemaUri (). isEmpty (); // issue credential from this template var valuesMap = new HashMap < String , Object > (); valuesMap . put ( \"firstName\" , \"Jane\" ); valuesMap . put ( \"lastName\" , \"Doe\" ); valuesMap . put ( \"age\" , 42 ); var valuesJson = new Gson (). toJson ( valuesMap ); var credentialJson = credentialService . issueCredentialFromTemplate ( VerifiableCredentials . IssueFromTemplateRequest . newBuilder (). setTemplateId ( template . getData (). getId ()). setValuesJson ( valuesJson ). build ()). get (); assert credentialJson != null ; assert ! credentialJson . getDocumentJson (). isEmpty (); var jsonDocument = new Gson (). fromJson ( credentialJson . getDocumentJson (), HashMap . class ); assert jsonDocument . containsKey ( \"id\" ); assert jsonDocument . containsKey ( \"credentialSubject\" ); } } Create an Ecosystem \u00b6 Trinsic CLI Typescript C# Python === \"Java\" --> Issue a Credential \u00b6 Upon receiving her vaccine, Allison also receives a digital certificate from the clinic. This certificate is digitally signed by the clinic, acting as an issuer. The certificate is in a JSON form, and for this example, we will use the following JSON. Add this file to your project named vaccination-certificate-unsigned.jsonld . vaccination-certificate-unsigned.jsonld { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://w3id.org/vaccination/v1\" , \"https://w3id.org/security/bbs/v1\" ], \"id\" : \"urn:uvci:af5vshde843jf831j128fj\" , \"type\" : [ \"VaccinationCertificate\" , \"VerifiableCredential\" ], \"description\" : \"COVID-19 Vaccination Certificate\" , \"name\" : \"COVID-19 Vaccination Certificate\" , \"expirationDate\" : \"2029-12-03T12:19:52Z\" , \"issuanceDate\" : \"2019-12-03T12:19:52Z\" , \"issuer\" : \"did:key:zUC724vuGvHpnCGFG1qqpXb81SiBLu3KLSqVzenwEZNPoY35i2Bscb8DLaVwHvRFs6F2NkNNXRcPWvqnPDUd9ukdjLkjZd3u9zzL4wDZDUpkPAatLDGLEYVo8kkAzuAKJQMr7N2\" , \"credentialSubject\" : { \"id\" : \"urn:uuid:c53e70f8-ce9a-4576-8744-e5f85c20a743\" , \"type\" : \"VaccinationEvent\" , \"batchNumber\" : \"1183738569\" , \"countryOfVaccination\" : \"US\" } } Behind the scenes, each credential is a JSON document that is signed with a special digital signature to make each piece of data in the credential separately verifiable. Signatures are a way to make sure that credentials are not forged or tampered with between getting issued and verified. They also are how a verifier can know that the credential was issued by who the credential says it was issued by. To issue this credential we'll specify links to the json files, set the active profile to the clinic, and call the issuance endpoint: Trinsic CLI Typescript C# Python Java Go trinsic --profile clinic issuer issue --document data/vaccination-certificate-unsigned.json --out vaccination-certificate-signed.json // Sign a credential as the clinic and send it to Allison const credentialJson = getVaccineCertUnsignedJSON () const credential = await credentialService . issueCredential ( new IssueRequest () . setDocumentJson ( JSON . stringify ( credentialJson ))); // Set active profile to 'clinic' so we can issue credential signed // with the clinic's signing keys walletService . Options . AuthToken = credentialsService . Options . AuthToken = clinic ; // Read the JSON credential data var credentialJson = await File . ReadAllTextAsync ( VaccinationCertificateUnsigned ); // Sign the credential using BBS+ signature scheme // issueCredentialSample() { var credential = await credentialsService . IssueCredentialAsync ( new () { DocumentJson = credentialJson }); _testOutputHelper . WriteLine ( $\"Credential:\\n{credential.SignedDocumentJson}\" ); // } // storeAndRecallProfile { // Serialize auth token by exporting it to file File . WriteAllText ( \"allison.txt\" , allison ); // Create auth token from existing data allison = File . ReadAllText ( \"allison.txt\" ); // } // STORE CREDENTIAL // Allison stores the credential in her cloud wallet. // storeCredential() { // Set active profile to 'allison' so we can manage her cloud wallet walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var insertItemResponse = await walletService . InsertItemAsync ( new () { ItemJson = credential . SignedDocumentJson }); var itemId = insertItemResponse . ItemId ; // searchWallet() { var walletItems = await walletService . SearchAsync ( new ()); // } _testOutputHelper . WriteLine ( $\"Last wallet item:\\n{walletItems.Items.Last()}\" ); // searchWalletSQL() { var walletItems2 = await walletService . SearchAsync ( new () { Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" }) // } // SHARE CREDENTIAL // Allison shares the credential with the venue. // The venue has communicated with Allison the details of the credential // that they require expressed as a JSON-LD frame. // shareCredential() { // We'll read the request frame from a file and communicate this with Allison walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var proofRequestJson = await File . ReadAllTextAsync ( VaccinationCertificateFrame ); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential var credentialProof = await credentialsService . CreateProofAsync ( new () { ItemId = itemId , RevealDocumentJson = proofRequestJson }); _testOutputHelper . WriteLine ( \"Proof:\" ); _testOutputHelper . WriteLine ( credentialProof . ProofDocumentJson ); // } // VERIFY CREDENTIAL // verifyCredential() { // The airline verifies the credential walletService . Options . AuthToken = credentialsService . Options . AuthToken = airline ; // Check for valid signature var valid = await credentialsService . VerifyProofAsync ( new () { ProofDocumentJson = credentialProof . ProofDocumentJson }); _testOutputHelper . WriteLine ( $\"Verification result: {valid.IsValid}\" ); Assert . True ( valid . IsValid ); // } } [Fact(DisplayName = \"Demo: trust registries\")] public async Task TestTrustRegistry () { // setup var providerService = new ProviderService ( _options . Clone ()); var ( _ , authToken ) = await providerService . CreateEcosystemAsync ( new ()); var service = new TrustRegistryService ( _options . CloneWithAuthToken ( authToken )); // register issuer var register = service . RegisterIssuerAsync ( new () { DidUri = \"did:example:test\" , GovernanceFrameworkUri = \"https://example.com\" , CredentialTypeUri = \"https://schema.org/Card\" }); await register ; register . Should (). NotBeNull (); register . Status . Should (). Be ( TaskStatus . RanToCompletion ); // register verifier register = service . RegisterVerifierAsync ( new () { DidUri = \"did:example:test\" , GovernanceFrameworkUri = \"https://example.com\" , PresentationTypeUri = \"https://schema.org/Card\" }); await register ; register . Should (). NotBeNull (); register . Status . Should (). Be ( TaskStatus . RanToCompletion ); // check issuer status var issuerStatus = await service . CheckIssuerStatusAsync ( new () { DidUri = \"did:example:test\" , GovernanceFrameworkUri = \"https://example.com\" , CredentialTypeUri = \"https://schema.org/Card\" }); issuerStatus . Should (). NotBeNull (); issuerStatus . Status . Should (). Be ( RegistrationStatus . Current ); // check verifier status var verifierStatus = await service . CheckVerifierStatusAsync ( new () { DidUri = \"did:example:test\" , GovernanceFrameworkUri = \"https://example.com\" , PresentationTypeUri = \"https://schema.org/Card\" }); verifierStatus . Status . Should (). Be ( RegistrationStatus . Current ); // search registry var searchResult = await service . SearchRegistryAsync ( new ()); searchResult . Should (). NotBeNull (); searchResult . ItemsJson . Should (). NotBeNull (). And . NotBeEmpty (); } [Fact(DisplayName = \"Demo: ecosystem creation and listing\")] public async Task EcosystemTests () { // setup var accountService = new AccountService ( _options ); var account = await accountService . SignInAsync ( new ()); var service = new ProviderService ( _options . CloneWithAuthToken ( account )); // test create ecosystem var ( actualCreate , _ ) = await service . CreateEcosystemAsync ( new () { Description = \"My ecosystem\" , Uri = \"https://example.com\" }); actualCreate . Should (). NotBeNull (); actualCreate . Id . Should (). NotBeNull (); actualCreate . Id . Should (). StartWith ( \"urn:trinsic:ecosystems:\" ); } [Fact] public async Task TestProtectUnprotectProfile () { // testSignInAndGetInfo() { var myAccountService = new AccountService ( _options ); var myProfile = await myAccountService . SignInAsync ( new ()); myAccountService . Options . AuthToken = myProfile ; var output = await myAccountService . GetInfoAsync (); Assert . NotNull ( output ); // } var securityCode = \"1234\" ; var myProtectedProfile = AccountService . Protect ( myProfile , securityCode ); myAccountService . Options . AuthToken = myProtectedProfile ; await Assert . ThrowsAsync < Exception >( myAccountService . GetInfoAsync ); var myUnprotectedProfile = AccountService . Unprotect ( myProtectedProfile , securityCode ); myAccountService . Options . AuthToken = myUnprotectedProfile ; Assert . NotNull ( await myAccountService . GetInfoAsync ()); Assert . NotNull ( myAccountService . GetInfo ()); } [Fact] public async Task TestInvitationIdSet () { var providerService = new ProviderService ( _options . Clone ()); _ = await providerService . CreateEcosystemAsync ( new ()); var invitationResponse = await providerService . InviteParticipantAsync ( new ()); invitationResponse . Should (). NotBeNull (); invitationResponse . InvitationCode . Should (). NotBeEmpty (); await Assert . ThrowsAsync < Exception >( async () => await providerService . InvitationStatusAsync ( new ())); } [Fact(Skip = \"Ecosystem support not complete yet\")] public async Task TestInviteParticipant () { var myAccountService = new AccountService ( _options ); var myProfile = await myAccountService . SignInAsync ( new ()); var myProviderService = new ProviderService ( _options . CloneWithAuthToken ( myProfile )); var invite = new InviteRequest { Description = \"Test invitation\" }; var response = await myProviderService . InviteParticipantAsync ( invite ); Assert . NotNull ( response ); var statusResponse = await myProviderService . InvitationStatusAsync ( new () { InvitationId = response . InvitationId }); Assert . NotNull ( statusResponse ); } [Fact] public async Task TestGovernanceFrameworkUriParse () { var myAccountService = new AccountService ( _options ); var myProfile = await myAccountService . SignInAsync ( new ()); var myTrustRegistryService = new TrustRegistryService ( _options . CloneWithAuthToken ( myProfile )); await Assert . ThrowsAsync < Exception >( async () => await myTrustRegistryService . RegisterGovernanceFrameworkAsync ( new () { GovernanceFramework = new () { Description = \"invalid uri\" , GovernanceFrameworkUri = \"\" } })); } [Fact(DisplayName = \"Demo: template management and credential issuance from template\")] public async Task DemoTemplatesWithIssuance () { var providerService = new ProviderService ( _options . Clone ()); var ( _ , authToken ) = await providerService . CreateEcosystemAsync ( new ()); var options = _options . CloneWithAuthToken ( authToken ); var templateService = new TemplateService ( options ); var credentialService = new CredentialsService ( options ); var walletService = new WalletService ( options ); // create example template // createTemplate() { CreateCredentialTemplateRequest templateRequest = new () { Name = \"An Example Credential\" , AllowAdditionalFields = false }; templateRequest . Fields . Add ( \"firstName\" , new () { Description = \"Given name\" }); templateRequest . Fields . Add ( \"lastName\" , new ()); templateRequest . Fields . Add ( \"age\" , new () { Type = FieldType . Number , Optional = true }); var template = await templateService . CreateAsync ( templateRequest ); // } template . Should (). NotBeNull (); template . Data . Should (). NotBeNull (); template . Data . Id . Should (). NotBeNull (); template . Data . SchemaUri . Should (). NotBeNull (); // issue credential from this template var values = JsonSerializer . Serialize ( new { firstName = \"Jane\" , lastName = \"Doe\" , age = \"42\" }); // issueFromTemplate() { var credentialJson = await credentialService . IssueFromTemplateAsync ( new () { TemplateId = template . Data . Id , ValuesJson = values }); // } credentialJson . Should (). NotBeNull (); var jsonDocument = JsonDocument . Parse ( credentialJson . DocumentJson ). RootElement . EnumerateObject (); jsonDocument . Should (). Contain ( x => x . Name == \"id\" ); jsonDocument . Should (). Contain ( x => x . Name == \"credentialSubject\" ); // insertItemWallet() { var insertItemResponse = await walletService . InsertItemAsync ( new () { ItemJson = credentialJson . DocumentJson }); // } var itemId = insertItemResponse . ItemId ; var frame = new JObject { { \"@context\" , \"https://www.w3.org/2018/credentials/v1\" }, { \"type\" , new JArray ( \"VerifiableCredential\" )} }; // Create proof from input document // createProof() { var proof = await credentialService . CreateProofAsync ( new () { DocumentJson = credentialJson . DocumentJson , RevealDocumentJson = frame . ToString ( Formatting . None ) }); // } // verifyProof() { var valid = await credentialService . VerifyProofAsync ( new () { ProofDocumentJson = proof . ProofDocumentJson }); // } valid . IsValid . Should (). BeTrue (); // Create proof from item id var proof2 = await credentialService . CreateProofAsync ( new () { ItemId = itemId , RevealDocumentJson = frame . ToString ( Formatting . None ) }); var valid2 = await credentialService . VerifyProofAsync ( new () { ProofDocumentJson = proof2 . ProofDocumentJson }); valid2 . IsValid . Should (). BeTrue (); } [Fact(DisplayName = \"Decode base64 url encoded string\")] public void DecodeBase64UrlString () { const string encoded = \"CiVodHRwczovL3RyaW5zaWMuaWQvc2VjdXJpdHkvdjEvb2Jlcm9uEnIKKnVybjp0cmluc2ljOndhbGxldHM6Vzl1dG9pVmhDZHp2RXJZRGVyOGlrRxIkODBkMTVlYTYtMTIxOS00MGZmLWE4NTQtZGI1NmZhOTlmNjMwIh51cm46dHJpbnNpYzplY29zeXN0ZW1zOmRlZmF1bHQaMJRXhevRbornRpA-HJ86WaTLGmQlOuoXSnDT_W2O3u3bV5rS5nKpgrfGKFEbRtIgjyIA\" ; var actual = Base64Url . Decode ( encoded ); actual . Should (). NotBeEmpty (); } We specify links to the jsonld files: def _base_data_path () -> str : return abspath ( join ( dirname ( __file__ ), \"..\" , \"..\" , \"devops\" , \"testdata\" )) def _vaccine_cert_unsigned_path () -> str : return abspath ( join ( _base_data_path (), \"vaccination-certificate-unsigned.jsonld\" )) def _vaccine_cert_frame_path () -> str : return abspath ( join ( _base_data_path (), \"vaccination-certificate-frame.jsonld\" )) Let's set the active profile to the clinic, and call the issuance endpoint issue_response = await credentials_service . issue_credential ( request = IssueRequest ( document_json = credential_json ) ) We specify links to the jsonld files: public static String baseTestPath () { return Path . of ( new File ( \"\" ). getAbsolutePath (), \"..\" , \"devops\" , \"testdata\" ). toAbsolutePath (). toString (); } public static Path vaccineCertUnsignedPath () { return Path . of ( baseTestPath (), \"vaccination-certificate-unsigned.jsonld\" ); } public static Path vaccineCertFramePath () { return Path . of ( baseTestPath (), \"vaccination-certificate-frame.jsonld\" ); } Let's set the active profile to the clinic, and call the issuance endpoint // Sign a credential as the clinic and send it to Allison var credentialJson = Files . readString ( vaccineCertUnsignedPath ()); var issueResult = credentialsService . issueCredential ( VerifiableCredentials . IssueRequest . newBuilder (). setDocumentJson ( credentialJson ). build ()). get (); var credential = issueResult . getSignedDocumentJson (); System . out . println ( \"Credential: \" + credential ); func GetBasePath () string { _ , fileName , _ , _ := runtime . Caller ( 1 ) path := filepath . Clean ( filepath . Join ( filepath . Dir ( fileName ), \"..\" , \"..\" , \"devops\" , \"testdata\" )) return path } func GetVaccineCertUnsignedPath () string { return filepath . Join ( GetBasePath (), \"vaccination-certificate-unsigned.jsonld\" ) } func GetVaccineCertFramePath () string { return filepath . Join ( GetBasePath (), \"vaccination-certificate-frame.jsonld\" ) } fileContent , err := ioutil . ReadFile ( GetVaccineCertUnsignedPath ()) failError ( t , \"error reading file\" , err ) credentialService . SetToken ( clinic ) credential , err := credentialService . IssueCredential ( context . Background (), & sdk . IssueRequest { DocumentJson : string ( fileContent )}) failError ( t , \"error issuing credential\" , err ) fmt . Printf ( \"Credential:%s\\n\" , credential ) Info Reference: Learn more about how to issue a credential Learn more about verifiable credentials Send Credential to Allison \u00b6 At this point, the clinic can send the signed credential to Allison using any available methods. These methods can include any message exchange protocol, or a custom transport. In this case, we'll assume that the credential was delivered to Allison in an offline environment. Sending credentials securely is an important part of maintaining the privacy of a credential holder. At this point we do not have a standard way of sending credentials to a wallet. There are a couple of options available. First, if you've onboarded two wallets on the Trinsic platform there is a way to send credentials to a wallet via the wallet's email address. This method is a temporary fix. We recommend using a secure channel of communication within your application for sending and receiving credentials. Sending via https or another encrypted messaging protocol is critical to ensure the personal information inside the credential is not accidentally leaked. As Trinsic's platform develops, we will embed an encrypted messaging protocol called DIDComm (decentralized identifier communication) to exchange credentials between any wallet. Info Dive Deeper: Learn more about how to exchange credentials Store Credential in Wallet \u00b6 Once Allison receives the credential, she or her wallet application can store it within her wallet. She can use any device that she's authorized to use with her wallet. Storing credentials securely is also important to maintaining Allison's privacy. Trinsic CLI Typescript C# Python Java Go trinsic --profile allison wallet insert-item --item vaccination-certificate-signed.json // Alice stores the credential in her cloud wallet. accountService . options . setAuthToken ( allison ); const itemId = await walletService . insertItem ( new InsertItemRequest () . setItemJson ( credential . getSignedDocumentJson ())); // Set active profile to 'allison' so we can manage her cloud wallet walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var insertItemResponse = await walletService . InsertItemAsync ( new () { ItemJson = credential . SignedDocumentJson }); var itemId = insertItemResponse . ItemId ; // searchWallet() { var walletItems = await walletService . SearchAsync ( new ()); // } _testOutputHelper . WriteLine ( $\"Last wallet item:\\n{walletItems.Items.Last()}\" ); // searchWalletSQL() { var walletItems2 = await walletService . SearchAsync ( new () { Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" }) // } // SHARE CREDENTIAL // Allison shares the credential with the venue. // The venue has communicated with Allison the details of the credential // that they require expressed as a JSON-LD frame. // shareCredential() { // We'll read the request frame from a file and communicate this with Allison walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var proofRequestJson = await File . ReadAllTextAsync ( VaccinationCertificateFrame ); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential var credentialProof = await credentialsService . CreateProofAsync ( new () { ItemId = itemId , RevealDocumentJson = proofRequestJson }); _testOutputHelper . WriteLine ( \"Proof:\" ); _testOutputHelper . WriteLine ( credentialProof . ProofDocumentJson ); // } // VERIFY CREDENTIAL // verifyCredential() { // The airline verifies the credential walletService . Options . AuthToken = credentialsService . Options . AuthToken = airline ; // Check for valid signature var valid = await credentialsService . VerifyProofAsync ( new () { ProofDocumentJson = credentialProof . ProofDocumentJson }); _testOutputHelper . WriteLine ( $\"Verification result: {valid.IsValid}\" ); Assert . True ( valid . IsValid ); // } # Alice stores the credential in her cloud wallet. wallet_service . service_options . auth_token = allison # insertItemWallet() { insert_response = await wallet_service . insert_item ( request = InsertItemRequest ( item_json = credential ) ) # } item_id = insert_response . item_id print ( f \"item id = { item_id } \" ) # searchWallet() { wallet_items = await wallet_service . search () # } # searchWalletSQL() { wallet_items2 = await wallet_service . search ( request = SearchRequest ( query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" )) # } print ( f \"last wallet item = { wallet_items . items [ - 1 ] } \" ) # shareCredential() { # Allison shares the credential with the venue. # The venue has communicated with Allison the details of the credential # that they require expressed as a JSON-LD frame. credentials_service . service_options . auth_token = allison wallet_service . service_options . auth_token = allison with open ( _vaccine_cert_frame_path (), \"r\" ) as fid2 : proof_request_json = \" \\n \" . join ( fid2 . readlines ()) # createProof() { proof_response = await credentials_service . create_proof ( request = CreateProofRequest ( reveal_document_json = proof_request_json , item_id = item_id ) ) # } credential_proof = proof_response . proof_document_json print ( f \"Proof: { credential_proof } \" ) # } # verifyCredential() { # The airline verifies the credential credentials_service . service_options . auth_token = airline wallet_service . service_options . auth_token = airline # verifyProof() { verify_result = await credentials_service . verify_proof ( request = VerifyProofRequest ( proof_document_json = credential_proof ) ) # } valid = verify_result . is_valid print ( f \"Verification result: { valid } \" ) assert valid is True # } # revokeCredential() { # update_status_response = await credentials_service.update_status(credential_status_id=status_id, revoked=True) # print(f\"UpdateStatusResponse: {update_status_response}\") # credential_status = await credentials_service.check_status(credential_status_id=status_id) # print(f\"Credential_status: {credential_status}\") # assert credential_status.revoked is True # } credentials_service . close () wallet_service . close () account_service . close () provider_service . close () if __name__ == \"__main__\" : asyncio . run ( vaccine_demo ()) // Alice stores the credential in her cloud wallet. var insertItemResponse = walletService . insertItem ( UniversalWalletOuterClass . InsertItemRequest . newBuilder (). setItemJson ( credential ). build ()). get (); final var itemId = insertItemResponse . getItemId (); System . out . println ( \"item id = \" + itemId ); walletService . SetToken ( allison ) failError ( t , \"error setting profile\" , err ) itemID , err := walletService . InsertItem ( context . Background (), & sdk . InsertItemRequest { ItemJson : credential . SignedDocumentJson }) failError ( t , \"error inserting item\" , err ) fmt . Println ( \"item id\" , itemID ) Note down the response item_id printed to the console for the next step. Info Reference: Insert Record Create a Proof of Vaccination \u00b6 Before boarding an airplane, Allison must show a proof of vaccination. The request for this proof also comes in a form of JSON, in this case a JSON-LD frame. This request can be communicated using any exchange protocol. Again, we'll assume this was done offline. Let's save this request in a file named vaccination-certificate-frame.jsonld vaccination-certificate-frame.jsonld { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://w3id.org/vaccination/v1\" , \"https://w3id.org/security/bbs/v1\" ], \"type\" : [ \"VerifiableCredential\" , \"VaccinationCertificate\" ], \"@explicit\" : true , \"issuer\" : {}, \"credentialSubject\" : { \"@explicit\" : true , \"@type\" : \"VaccinationEvent\" , \"batchNumber\" : {}, \"countryOfVaccination\" : {} } } This request asks Allison to provide proof of valid vaccination certificate, including the issuer , batchNumber and countryOfVaccination fields. Allison can use the Create Proof functions to build a proof that will share only the requested fields. Now let's create a proof for Allison. She may choose to generate this proof before going to the airport, or might generate it right as she boards. Trinsic CLI Typescript C# Python Java Go Replace the <item_id> in the generate proof command below with the output from the insert_item above. trinsic --profile allison issuer create-proof --document-id \"<item-id>\" --out vaccination-certificate-partial-proof.json --reveal-document data/vaccination-certificate-frame.json // Allison shares the credential with the venue. // The venue has communicated with Allison the details of the credential // that they require expressed as a JSON-LD frame. credentialService . options . setAuthToken ( allison ); const proofRequestJson = getVaccineCertFrameJSON (); const proof = await credentialService . createProof ( new CreateProofRequest () . setItemId ( itemId . getItemId ()) . setRevealDocumentJson ( JSON . stringify ( proofRequestJson ))); // We'll read the request frame from a file and communicate this with Allison walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var proofRequestJson = await File . ReadAllTextAsync ( VaccinationCertificateFrame ); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential var credentialProof = await credentialsService . CreateProofAsync ( new () { ItemId = itemId , RevealDocumentJson = proofRequestJson }); _testOutputHelper . WriteLine ( \"Proof:\" ); _testOutputHelper . WriteLine ( credentialProof . ProofDocumentJson ); # Allison shares the credential with the venue. # The venue has communicated with Allison the details of the credential # that they require expressed as a JSON-LD frame. credentials_service . service_options . auth_token = allison wallet_service . service_options . auth_token = allison with open ( _vaccine_cert_frame_path (), \"r\" ) as fid2 : proof_request_json = \" \\n \" . join ( fid2 . readlines ()) # createProof() { proof_response = await credentials_service . create_proof ( request = CreateProofRequest ( reveal_document_json = proof_request_json , item_id = item_id ) ) # } credential_proof = proof_response . proof_document_json print ( f \"Proof: { credential_proof } \" ) // Allison shares the credential with the venue. // The venue has communicated with Allison the details of the credential // that they require expressed as a JSON-LD frame. credentialsService . setProfile ( allison ); var proofRequestJson = Files . readString ( vaccineCertFramePath ()); var createProofResponse = credentialsService . createProof ( VerifiableCredentials . CreateProofRequest . newBuilder (). setItemId ( itemId ). setRevealDocumentJson ( proofRequestJson ). build ()). get (); var credentialProof = createProofResponse . getProofDocumentJson (); System . out . println ( \"Proof: \" + credentialProof ); walletService . SetToken ( allison ) failError ( t , \"error reading file\" , err ) fileContent2 , err := ioutil . ReadFile ( GetVaccineCertFramePath ()) failError ( t , \"error reading file\" , err ) req := & sdk . CreateProofRequest { RevealDocumentJson : string ( fileContent2 ), Proof : & sdk . CreateProofRequest_ItemId { ItemId : itemID }, } credentialService . SetToken ( allison ) credentialProof , err := credentialService . CreateProof ( context . Background (), req ) failError ( t , \"error creating proof\" , err ) fmt . Println ( \"Credential proof\" , credentialProof ) Take a look at the proof. Notice how only the attributes included in the frame are included with the proof. Allison sends this proof to the airline for them to verify. Info Reference: Create Proof Verify Proof \u00b6 Once the airline receives the proof, they can now verify it to ensure its authenticity. Because Allison sent a proof of her vaccination credential and not the credential itself, the airline only receives its required information. Trinsic CLI Typescript C# Python Java Go trinsic --profile airline issuer verify-proof --proof-document vaccination-certificate-partial-proof.json // The airline verifies the credential credentialService . options . setAuthToken ( airline ); const verifyResponse = await credentialService . verifyProof ( new VerifyProofRequest () . setProofDocumentJson ( proof . getProofDocumentJson ())); // The airline verifies the credential walletService . Options . AuthToken = credentialsService . Options . AuthToken = airline ; // Check for valid signature var valid = await credentialsService . VerifyProofAsync ( new () { ProofDocumentJson = credentialProof . ProofDocumentJson }); _testOutputHelper . WriteLine ( $\"Verification result: {valid.IsValid}\" ); Assert . True ( valid . IsValid ); # The airline verifies the credential credentials_service . service_options . auth_token = airline wallet_service . service_options . auth_token = airline # verifyProof() { verify_result = await credentials_service . verify_proof ( request = VerifyProofRequest ( proof_document_json = credential_proof ) ) # } valid = verify_result . is_valid print ( f \"Verification result: { valid } \" ) assert valid is True // The airline verifies the credential credentialsService . setProfile ( airline ); var verifyProofResponse = credentialsService . verifyProof ( VerifiableCredentials . VerifyProofRequest . newBuilder (). setProofDocumentJson ( credentialProof ). build ()). get (); var isValid = verifyProofResponse . getIsValid (); System . out . println ( \"Verification result: \" + isValid ); Assertions . assertTrue ( isValid ); walletService . SetToken ( airline ) failError ( t , \"error setting profile\" , err ) valid , err := credentialService . VerifyProof ( context . Background (), & sdk . VerifyProofRequest { ProofDocumentJson : credential . SignedDocumentJson }) failError ( t , \"error verifying proof\" , err ) fmt . Println ( \"Validation result\" , valid ) if valid != true { t . Fail () } Watch for the result of true to know that the credential successfully passed all of the verification processes. Info Reference: Verify Proof Full Source Code \u00b6 Typescript C# Python Java browser node This sample is available in our dotnet directory. <!-- ??? You can also run the code using Replit and inspect the results. example \"Run example in Replit\" <iframe frameborder=\"0\" width=\"100%\" height=\"650px\" src=\"https://replit.com/@trinsic/VaccinationSample-dotnet?lite=true\"></iframe> --> This sample is available as ecosystem_demo.py This sample is available in the Java directory. Next Steps: \u00b6 Congratulations! If you've completed all the steps of this walkthrough, you've just created a mini ecosystem of issuers, verifiers, and holders all exchanging credentials. Depending on your goals, there are a couple of possible next steps to take. Try out a sample app Learn more about wallets, credentials, templates, and ecosystems Review the SDK Reference Sample Applications \u00b6 We have language specific sample applications that you can run to understand how the Trinsic SDK works in a development environment. Typescript C# Python The tests folder in the [browser] This sample is available in our dotnet subdirectory. You can also simply run the code using Replit and inspect the results. This sample is available in the python directory Java This sample is available in our Github repo in the java directory .","title":"Try the Walkthrough"},{"location":"walkthroughs/vaccination/#walkthrough","text":"This walkthrough will show how a vaccination card can be issued, held, and proven using verifiable credentials with the Trinsic CLI. Feel free to follow along in a terminal using the CLI. We'll cover each part of Trinsic's platform during the tutorial.","title":"Walkthrough"},{"location":"walkthroughs/vaccination/#meet-allison","text":"In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Verifier : Verifies passes presented from holders. In this case, Allison will be the holder, a vaccination clinic will be an issuer, and an airline will be the verifier. walkthrough |- allison - Holder |- clinic - Issuer |- airline - Verifier","title":"Meet Allison"},{"location":"walkthroughs/vaccination/#our-sdks","text":"This tutorial is meant to share the concepts of verifiable credentials. So feel free to sit back and read through this without running any code. However, you can also follow along using one of our SDKs. We've set up some environments to use on Repl.it. If your language of choice isn't supported on repl.it, you can also run locally by installing the SDK of your choice. Trinsic CLI TypeScript C# Python Java Ruby Go Installation instructions for the Trinsic CLI. Once the CLI is installed, clone our CLI example repository on Github to download the credential data for this walkthrough. git clone https://github.com/trinsic-id/cli-example && cd cli-example If you don't want to install locally, we also have a replit environment for you to use. In a new tab, you can open our to use the CLI. This demo environment works best when run side-by-side the following walkthrough using two tabs in your browser. Installation instructions for the Node SDK. Installation instructions for the Browser SDk. Let's create a new .NET console app that we will use to add our sample code dotnet new console -n TrinsicSample && cd TrinsicSample Now we'll follow the installation instructions for Dotnet. Installation instructions for Python. Installation instructions for Java. In this project, we'll be following along the java/src/test/java/trinsic/VaccineDemo.java in our SDK repository Install Instructions Install Instructions","title":"Our SDKs"},{"location":"walkthroughs/vaccination/#creating-accounts","text":"We'll start by creating a Trinsic Wallet for each participant in this credential exchange. Wallets can be created by anyone, for anyone. In this scenario, we'll have three wallets. Allison will be the credential holder, the Airline will be the verifier, and the vaccination clinic will be the issuer. When a new Trinsic account is created, a cloud wallet is created on our platform and an authentication key is generated by our SDK locally. Each person is the sole owner of their cloud wallet. They're meant to be easy to create so that you can create a cloud wallet for an end-user in your UX with very little friction. Trinsic CLI Typescript C# Python Java Go The CLI offers an interactive way of creating wallets. For demo purposes, we'll create all three on the same machine. However, this demo could be done with all three wallets created on three separate machines. When creating a wallet in the CLI, the wallet will store a private authentication token for the wallet in ~/.trinsic. If using the CLI with a real-world wallet, store this authentication token somewhere securely. trinsic account login --description \"Allison's Wallet\" --alias allison && \\ trinsic account login --description \"Airline's wallet\" --alias airline && \\ trinsic account login --description \"Vaccination Clinic\" --alias clinic // Create 3 different profiles for each participant in the scenario const allison = await accountService . signIn ( new SignInRequest ()); const clinic = await accountService . signIn ( new SignInRequest ()); const airline = await accountService . signIn ( new SignInRequest ()); var allison = await accountService . SignInAsync ( new () { EcosystemId = ecosystemId }); var clinic = await accountService . SignInAsync ( new () { EcosystemId = ecosystemId }); var airline = await accountService . SignInAsync ( new () { EcosystemId = ecosystemId }); # Create 3 different profiles for each participant in the scenario allison = await account_service . sign_in ( request = SignInRequest ( ecosystem_id = ecosystem_id ) ) clinic = await account_service . sign_in ( request = SignInRequest ( ecosystem_id = ecosystem_id ) ) airline = await account_service . sign_in ( request = SignInRequest ( ecosystem_id = ecosystem_id ) ) // Create 3 different profiles for each participant in the scenario var allison = accountService . signIn (). get (); var clinic = accountService . signIn (). get (); var airline = accountService . signIn (). get (); allison , _ , err := accountService . SignIn ( context . Background (), & sdk . SignInRequest {}) failError ( t , \"error creating profile\" , err ) if ! assert2 . NotNil ( allison ) { return } clinic , _ , err := accountService . SignIn ( context . Background (), & sdk . SignInRequest {}) failError ( t , \"error creating profile\" , err ) if ! assert2 . NotNil ( clinic ) { return } airline , _ , err := accountService . SignIn ( context . Background (), & sdk . SignInRequest {}) failError ( t , \"error creating profile\" , err ) if ! assert2 . NotNil ( airline ) { return } If you would like to save the profile for future use, you can simply export the serialized profile to a local storage. Please note that the profiles contain sensitive key data, so they should be stored in a secure enclave. C# Python Java Go // Serialize auth token by exporting it to file File . WriteAllText ( \"allison.txt\" , allison ); // Create auth token from existing data allison = File . ReadAllText ( \"allison.txt\" ); # Store profile for later use with open ( \"allison.txt\" , \"wb\" ) as fid : fid . write ( allison . encode ( \"utf-8\" )) # Create profile from existing data with open ( \"allison.txt\" , \"rb\" ) as fid : allison = fid . readline () var writeFile = new BufferedWriter ( new FileWriter ( \"allison.txt\" )); writeFile . write ( allison ); writeFile . flush (); writeFile . close (); // Create profile from existing data var readFile = new BufferedReader ( new FileReader ( \"allison.txt\" )); allison = readFile . readLine (). strip (); readFile . close (); // Store profile for later use // File.WriteAllBytes(\"allison.bin\", allison.ToByteString().ToByteArray()); // Create profile from existing data // var allison = WalletProfile.Parser.ParseFrom(File.ReadAllBytes(\"allison.bin\")); Note References: Manage access to cloud wallets with the Account Service Learn more about Wallets Read more about security profiles and authentication.","title":"Creating Accounts"},{"location":"walkthroughs/vaccination/#define-a-template","text":"Trinsic CLI Typescript C# Python Java var credentialTemplateName = \"My First Credential Template\" ; var nameField = new TemplateField (); nameField . setType ( FieldType . STRING ); nameField . setDescription ( \"The name of the person\" ); nameField . setOptional ( false ); var numberOfBags = new TemplateField (); numberOfBags . setType ( FieldType . NUMBER ); numberOfBags . setDescription ( \"The number of bags the person is taking on the trip\" ); numberOfBags . setOptional ( false ); var dateOfBirth = new TemplateField (); dateOfBirth . setType ( FieldType . DATETIME ); dateOfBirth . setDescription ( \"The date of birth of the person\" ); dateOfBirth . setOptional ( false ); var isVaccinated = new TemplateField (); isVaccinated . setType ( FieldType . BOOL ); isVaccinated . setDescription ( \"Whether or not the person has been vaccinated\" ); isVaccinated . setOptional ( false ); const templateService = new TemplateService ( options ); let request = new CreateCredentialTemplateRequest (); request . setName ( credentialTemplateName ); request . getFieldsMap () . set ( \"name\" , nameField ) . set ( \"numberOfBags\" , numberOfBags ) . set ( \"dateOfBirth\" , dateOfBirth ) . set ( \"vaccinated\" , isVaccinated ); let response = await templateService . createCredentialTemplate ( request ); CreateCredentialTemplateRequest templateRequest = new () { Name = \"An Example Credential\" , AllowAdditionalFields = false }; templateRequest . Fields . Add ( \"firstName\" , new () { Description = \"Given name\" }); templateRequest . Fields . Add ( \"lastName\" , new ()); templateRequest . Fields . Add ( \"age\" , new () { Type = FieldType . Number , Optional = true }); var template = await templateService . CreateAsync ( templateRequest ); template = await template_service . create ( request = CreateCredentialTemplateRequest ( name = \"An Example Credential\" , allow_additional_fields = False , fields = { \"firstName\" : TemplateField ( description = \"Given name\" ), \"lastName\" : TemplateField (), \"age\" : TemplateField ( type = FieldType . NUMBER , optional = True ), }, ) ) package trinsic ; import com.google.gson.Gson ; import trinsic.okapi.DidException ; import trinsic.services.AccountService ; import trinsic.services.CredentialTemplateService ; import trinsic.services.CredentialsService ; import trinsic.services.verifiablecredentials.templates.v1.Templates ; import trinsic.services.verifiablecredentials.v1.VerifiableCredentials ; import java.io.IOException ; import java.util.HashMap ; import java.util.concurrent.ExecutionException ; public class TemplatesDemo { public static void main ( String [] args ) throws IOException , DidException , ExecutionException , InterruptedException { run (); } public static void run () throws IOException , DidException , ExecutionException , InterruptedException { var accountService = new AccountService ( TrinsicUtilities . getTrinsicServiceOptions ()); var account = accountService . signIn (). get (); var templateService = new CredentialTemplateService ( TrinsicUtilities . getTrinsicServiceOptions ( account )); var credentialService = new CredentialsService ( TrinsicUtilities . getTrinsicServiceOptions ( account )); // create example template var fields = new HashMap < String , Templates . TemplateField > (); fields . put ( \"firstName\" , Templates . TemplateField . newBuilder (). setDescription ( \"Given name\" ). build ()); fields . put ( \"lastName\" , Templates . TemplateField . newBuilder (). build ()); fields . put ( \"age\" , Templates . TemplateField . newBuilder (). setType ( Templates . FieldType . NUMBER ). setOptional ( true ). build ()); var templateRequest = Templates . CreateCredentialTemplateRequest . newBuilder (). setName ( \"My Example Credential\" ). setAllowAdditionalFields ( false ). putAllFields ( fields ). build (); var template = templateService . create ( templateRequest ). get (); assert template != null ; assert template . hasData (); assert ! template . getData (). getId (). isEmpty (); assert ! template . getData (). getSchemaUri (). isEmpty (); // issue credential from this template var valuesMap = new HashMap < String , Object > (); valuesMap . put ( \"firstName\" , \"Jane\" ); valuesMap . put ( \"lastName\" , \"Doe\" ); valuesMap . put ( \"age\" , 42 ); var valuesJson = new Gson (). toJson ( valuesMap ); var credentialJson = credentialService . issueCredentialFromTemplate ( VerifiableCredentials . IssueFromTemplateRequest . newBuilder (). setTemplateId ( template . getData (). getId ()). setValuesJson ( valuesJson ). build ()). get (); assert credentialJson != null ; assert ! credentialJson . getDocumentJson (). isEmpty (); var jsonDocument = new Gson (). fromJson ( credentialJson . getDocumentJson (), HashMap . class ); assert jsonDocument . containsKey ( \"id\" ); assert jsonDocument . containsKey ( \"credentialSubject\" ); } }","title":"Define a Template"},{"location":"walkthroughs/vaccination/#create-an-ecosystem","text":"Trinsic CLI Typescript C# Python === \"Java\" -->","title":"Create an Ecosystem"},{"location":"walkthroughs/vaccination/#issue-a-credential","text":"Upon receiving her vaccine, Allison also receives a digital certificate from the clinic. This certificate is digitally signed by the clinic, acting as an issuer. The certificate is in a JSON form, and for this example, we will use the following JSON. Add this file to your project named vaccination-certificate-unsigned.jsonld . vaccination-certificate-unsigned.jsonld { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://w3id.org/vaccination/v1\" , \"https://w3id.org/security/bbs/v1\" ], \"id\" : \"urn:uvci:af5vshde843jf831j128fj\" , \"type\" : [ \"VaccinationCertificate\" , \"VerifiableCredential\" ], \"description\" : \"COVID-19 Vaccination Certificate\" , \"name\" : \"COVID-19 Vaccination Certificate\" , \"expirationDate\" : \"2029-12-03T12:19:52Z\" , \"issuanceDate\" : \"2019-12-03T12:19:52Z\" , \"issuer\" : \"did:key:zUC724vuGvHpnCGFG1qqpXb81SiBLu3KLSqVzenwEZNPoY35i2Bscb8DLaVwHvRFs6F2NkNNXRcPWvqnPDUd9ukdjLkjZd3u9zzL4wDZDUpkPAatLDGLEYVo8kkAzuAKJQMr7N2\" , \"credentialSubject\" : { \"id\" : \"urn:uuid:c53e70f8-ce9a-4576-8744-e5f85c20a743\" , \"type\" : \"VaccinationEvent\" , \"batchNumber\" : \"1183738569\" , \"countryOfVaccination\" : \"US\" } } Behind the scenes, each credential is a JSON document that is signed with a special digital signature to make each piece of data in the credential separately verifiable. Signatures are a way to make sure that credentials are not forged or tampered with between getting issued and verified. They also are how a verifier can know that the credential was issued by who the credential says it was issued by. To issue this credential we'll specify links to the json files, set the active profile to the clinic, and call the issuance endpoint: Trinsic CLI Typescript C# Python Java Go trinsic --profile clinic issuer issue --document data/vaccination-certificate-unsigned.json --out vaccination-certificate-signed.json // Sign a credential as the clinic and send it to Allison const credentialJson = getVaccineCertUnsignedJSON () const credential = await credentialService . issueCredential ( new IssueRequest () . setDocumentJson ( JSON . stringify ( credentialJson ))); // Set active profile to 'clinic' so we can issue credential signed // with the clinic's signing keys walletService . Options . AuthToken = credentialsService . Options . AuthToken = clinic ; // Read the JSON credential data var credentialJson = await File . ReadAllTextAsync ( VaccinationCertificateUnsigned ); // Sign the credential using BBS+ signature scheme // issueCredentialSample() { var credential = await credentialsService . IssueCredentialAsync ( new () { DocumentJson = credentialJson }); _testOutputHelper . WriteLine ( $\"Credential:\\n{credential.SignedDocumentJson}\" ); // } // storeAndRecallProfile { // Serialize auth token by exporting it to file File . WriteAllText ( \"allison.txt\" , allison ); // Create auth token from existing data allison = File . ReadAllText ( \"allison.txt\" ); // } // STORE CREDENTIAL // Allison stores the credential in her cloud wallet. // storeCredential() { // Set active profile to 'allison' so we can manage her cloud wallet walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var insertItemResponse = await walletService . InsertItemAsync ( new () { ItemJson = credential . SignedDocumentJson }); var itemId = insertItemResponse . ItemId ; // searchWallet() { var walletItems = await walletService . SearchAsync ( new ()); // } _testOutputHelper . WriteLine ( $\"Last wallet item:\\n{walletItems.Items.Last()}\" ); // searchWalletSQL() { var walletItems2 = await walletService . SearchAsync ( new () { Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" }) // } // SHARE CREDENTIAL // Allison shares the credential with the venue. // The venue has communicated with Allison the details of the credential // that they require expressed as a JSON-LD frame. // shareCredential() { // We'll read the request frame from a file and communicate this with Allison walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var proofRequestJson = await File . ReadAllTextAsync ( VaccinationCertificateFrame ); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential var credentialProof = await credentialsService . CreateProofAsync ( new () { ItemId = itemId , RevealDocumentJson = proofRequestJson }); _testOutputHelper . WriteLine ( \"Proof:\" ); _testOutputHelper . WriteLine ( credentialProof . ProofDocumentJson ); // } // VERIFY CREDENTIAL // verifyCredential() { // The airline verifies the credential walletService . Options . AuthToken = credentialsService . Options . AuthToken = airline ; // Check for valid signature var valid = await credentialsService . VerifyProofAsync ( new () { ProofDocumentJson = credentialProof . ProofDocumentJson }); _testOutputHelper . WriteLine ( $\"Verification result: {valid.IsValid}\" ); Assert . True ( valid . IsValid ); // } } [Fact(DisplayName = \"Demo: trust registries\")] public async Task TestTrustRegistry () { // setup var providerService = new ProviderService ( _options . Clone ()); var ( _ , authToken ) = await providerService . CreateEcosystemAsync ( new ()); var service = new TrustRegistryService ( _options . CloneWithAuthToken ( authToken )); // register issuer var register = service . RegisterIssuerAsync ( new () { DidUri = \"did:example:test\" , GovernanceFrameworkUri = \"https://example.com\" , CredentialTypeUri = \"https://schema.org/Card\" }); await register ; register . Should (). NotBeNull (); register . Status . Should (). Be ( TaskStatus . RanToCompletion ); // register verifier register = service . RegisterVerifierAsync ( new () { DidUri = \"did:example:test\" , GovernanceFrameworkUri = \"https://example.com\" , PresentationTypeUri = \"https://schema.org/Card\" }); await register ; register . Should (). NotBeNull (); register . Status . Should (). Be ( TaskStatus . RanToCompletion ); // check issuer status var issuerStatus = await service . CheckIssuerStatusAsync ( new () { DidUri = \"did:example:test\" , GovernanceFrameworkUri = \"https://example.com\" , CredentialTypeUri = \"https://schema.org/Card\" }); issuerStatus . Should (). NotBeNull (); issuerStatus . Status . Should (). Be ( RegistrationStatus . Current ); // check verifier status var verifierStatus = await service . CheckVerifierStatusAsync ( new () { DidUri = \"did:example:test\" , GovernanceFrameworkUri = \"https://example.com\" , PresentationTypeUri = \"https://schema.org/Card\" }); verifierStatus . Status . Should (). Be ( RegistrationStatus . Current ); // search registry var searchResult = await service . SearchRegistryAsync ( new ()); searchResult . Should (). NotBeNull (); searchResult . ItemsJson . Should (). NotBeNull (). And . NotBeEmpty (); } [Fact(DisplayName = \"Demo: ecosystem creation and listing\")] public async Task EcosystemTests () { // setup var accountService = new AccountService ( _options ); var account = await accountService . SignInAsync ( new ()); var service = new ProviderService ( _options . CloneWithAuthToken ( account )); // test create ecosystem var ( actualCreate , _ ) = await service . CreateEcosystemAsync ( new () { Description = \"My ecosystem\" , Uri = \"https://example.com\" }); actualCreate . Should (). NotBeNull (); actualCreate . Id . Should (). NotBeNull (); actualCreate . Id . Should (). StartWith ( \"urn:trinsic:ecosystems:\" ); } [Fact] public async Task TestProtectUnprotectProfile () { // testSignInAndGetInfo() { var myAccountService = new AccountService ( _options ); var myProfile = await myAccountService . SignInAsync ( new ()); myAccountService . Options . AuthToken = myProfile ; var output = await myAccountService . GetInfoAsync (); Assert . NotNull ( output ); // } var securityCode = \"1234\" ; var myProtectedProfile = AccountService . Protect ( myProfile , securityCode ); myAccountService . Options . AuthToken = myProtectedProfile ; await Assert . ThrowsAsync < Exception >( myAccountService . GetInfoAsync ); var myUnprotectedProfile = AccountService . Unprotect ( myProtectedProfile , securityCode ); myAccountService . Options . AuthToken = myUnprotectedProfile ; Assert . NotNull ( await myAccountService . GetInfoAsync ()); Assert . NotNull ( myAccountService . GetInfo ()); } [Fact] public async Task TestInvitationIdSet () { var providerService = new ProviderService ( _options . Clone ()); _ = await providerService . CreateEcosystemAsync ( new ()); var invitationResponse = await providerService . InviteParticipantAsync ( new ()); invitationResponse . Should (). NotBeNull (); invitationResponse . InvitationCode . Should (). NotBeEmpty (); await Assert . ThrowsAsync < Exception >( async () => await providerService . InvitationStatusAsync ( new ())); } [Fact(Skip = \"Ecosystem support not complete yet\")] public async Task TestInviteParticipant () { var myAccountService = new AccountService ( _options ); var myProfile = await myAccountService . SignInAsync ( new ()); var myProviderService = new ProviderService ( _options . CloneWithAuthToken ( myProfile )); var invite = new InviteRequest { Description = \"Test invitation\" }; var response = await myProviderService . InviteParticipantAsync ( invite ); Assert . NotNull ( response ); var statusResponse = await myProviderService . InvitationStatusAsync ( new () { InvitationId = response . InvitationId }); Assert . NotNull ( statusResponse ); } [Fact] public async Task TestGovernanceFrameworkUriParse () { var myAccountService = new AccountService ( _options ); var myProfile = await myAccountService . SignInAsync ( new ()); var myTrustRegistryService = new TrustRegistryService ( _options . CloneWithAuthToken ( myProfile )); await Assert . ThrowsAsync < Exception >( async () => await myTrustRegistryService . RegisterGovernanceFrameworkAsync ( new () { GovernanceFramework = new () { Description = \"invalid uri\" , GovernanceFrameworkUri = \"\" } })); } [Fact(DisplayName = \"Demo: template management and credential issuance from template\")] public async Task DemoTemplatesWithIssuance () { var providerService = new ProviderService ( _options . Clone ()); var ( _ , authToken ) = await providerService . CreateEcosystemAsync ( new ()); var options = _options . CloneWithAuthToken ( authToken ); var templateService = new TemplateService ( options ); var credentialService = new CredentialsService ( options ); var walletService = new WalletService ( options ); // create example template // createTemplate() { CreateCredentialTemplateRequest templateRequest = new () { Name = \"An Example Credential\" , AllowAdditionalFields = false }; templateRequest . Fields . Add ( \"firstName\" , new () { Description = \"Given name\" }); templateRequest . Fields . Add ( \"lastName\" , new ()); templateRequest . Fields . Add ( \"age\" , new () { Type = FieldType . Number , Optional = true }); var template = await templateService . CreateAsync ( templateRequest ); // } template . Should (). NotBeNull (); template . Data . Should (). NotBeNull (); template . Data . Id . Should (). NotBeNull (); template . Data . SchemaUri . Should (). NotBeNull (); // issue credential from this template var values = JsonSerializer . Serialize ( new { firstName = \"Jane\" , lastName = \"Doe\" , age = \"42\" }); // issueFromTemplate() { var credentialJson = await credentialService . IssueFromTemplateAsync ( new () { TemplateId = template . Data . Id , ValuesJson = values }); // } credentialJson . Should (). NotBeNull (); var jsonDocument = JsonDocument . Parse ( credentialJson . DocumentJson ). RootElement . EnumerateObject (); jsonDocument . Should (). Contain ( x => x . Name == \"id\" ); jsonDocument . Should (). Contain ( x => x . Name == \"credentialSubject\" ); // insertItemWallet() { var insertItemResponse = await walletService . InsertItemAsync ( new () { ItemJson = credentialJson . DocumentJson }); // } var itemId = insertItemResponse . ItemId ; var frame = new JObject { { \"@context\" , \"https://www.w3.org/2018/credentials/v1\" }, { \"type\" , new JArray ( \"VerifiableCredential\" )} }; // Create proof from input document // createProof() { var proof = await credentialService . CreateProofAsync ( new () { DocumentJson = credentialJson . DocumentJson , RevealDocumentJson = frame . ToString ( Formatting . None ) }); // } // verifyProof() { var valid = await credentialService . VerifyProofAsync ( new () { ProofDocumentJson = proof . ProofDocumentJson }); // } valid . IsValid . Should (). BeTrue (); // Create proof from item id var proof2 = await credentialService . CreateProofAsync ( new () { ItemId = itemId , RevealDocumentJson = frame . ToString ( Formatting . None ) }); var valid2 = await credentialService . VerifyProofAsync ( new () { ProofDocumentJson = proof2 . ProofDocumentJson }); valid2 . IsValid . Should (). BeTrue (); } [Fact(DisplayName = \"Decode base64 url encoded string\")] public void DecodeBase64UrlString () { const string encoded = \"CiVodHRwczovL3RyaW5zaWMuaWQvc2VjdXJpdHkvdjEvb2Jlcm9uEnIKKnVybjp0cmluc2ljOndhbGxldHM6Vzl1dG9pVmhDZHp2RXJZRGVyOGlrRxIkODBkMTVlYTYtMTIxOS00MGZmLWE4NTQtZGI1NmZhOTlmNjMwIh51cm46dHJpbnNpYzplY29zeXN0ZW1zOmRlZmF1bHQaMJRXhevRbornRpA-HJ86WaTLGmQlOuoXSnDT_W2O3u3bV5rS5nKpgrfGKFEbRtIgjyIA\" ; var actual = Base64Url . Decode ( encoded ); actual . Should (). NotBeEmpty (); } We specify links to the jsonld files: def _base_data_path () -> str : return abspath ( join ( dirname ( __file__ ), \"..\" , \"..\" , \"devops\" , \"testdata\" )) def _vaccine_cert_unsigned_path () -> str : return abspath ( join ( _base_data_path (), \"vaccination-certificate-unsigned.jsonld\" )) def _vaccine_cert_frame_path () -> str : return abspath ( join ( _base_data_path (), \"vaccination-certificate-frame.jsonld\" )) Let's set the active profile to the clinic, and call the issuance endpoint issue_response = await credentials_service . issue_credential ( request = IssueRequest ( document_json = credential_json ) ) We specify links to the jsonld files: public static String baseTestPath () { return Path . of ( new File ( \"\" ). getAbsolutePath (), \"..\" , \"devops\" , \"testdata\" ). toAbsolutePath (). toString (); } public static Path vaccineCertUnsignedPath () { return Path . of ( baseTestPath (), \"vaccination-certificate-unsigned.jsonld\" ); } public static Path vaccineCertFramePath () { return Path . of ( baseTestPath (), \"vaccination-certificate-frame.jsonld\" ); } Let's set the active profile to the clinic, and call the issuance endpoint // Sign a credential as the clinic and send it to Allison var credentialJson = Files . readString ( vaccineCertUnsignedPath ()); var issueResult = credentialsService . issueCredential ( VerifiableCredentials . IssueRequest . newBuilder (). setDocumentJson ( credentialJson ). build ()). get (); var credential = issueResult . getSignedDocumentJson (); System . out . println ( \"Credential: \" + credential ); func GetBasePath () string { _ , fileName , _ , _ := runtime . Caller ( 1 ) path := filepath . Clean ( filepath . Join ( filepath . Dir ( fileName ), \"..\" , \"..\" , \"devops\" , \"testdata\" )) return path } func GetVaccineCertUnsignedPath () string { return filepath . Join ( GetBasePath (), \"vaccination-certificate-unsigned.jsonld\" ) } func GetVaccineCertFramePath () string { return filepath . Join ( GetBasePath (), \"vaccination-certificate-frame.jsonld\" ) } fileContent , err := ioutil . ReadFile ( GetVaccineCertUnsignedPath ()) failError ( t , \"error reading file\" , err ) credentialService . SetToken ( clinic ) credential , err := credentialService . IssueCredential ( context . Background (), & sdk . IssueRequest { DocumentJson : string ( fileContent )}) failError ( t , \"error issuing credential\" , err ) fmt . Printf ( \"Credential:%s\\n\" , credential ) Info Reference: Learn more about how to issue a credential Learn more about verifiable credentials","title":"Issue a Credential"},{"location":"walkthroughs/vaccination/#send-credential-to-allison","text":"At this point, the clinic can send the signed credential to Allison using any available methods. These methods can include any message exchange protocol, or a custom transport. In this case, we'll assume that the credential was delivered to Allison in an offline environment. Sending credentials securely is an important part of maintaining the privacy of a credential holder. At this point we do not have a standard way of sending credentials to a wallet. There are a couple of options available. First, if you've onboarded two wallets on the Trinsic platform there is a way to send credentials to a wallet via the wallet's email address. This method is a temporary fix. We recommend using a secure channel of communication within your application for sending and receiving credentials. Sending via https or another encrypted messaging protocol is critical to ensure the personal information inside the credential is not accidentally leaked. As Trinsic's platform develops, we will embed an encrypted messaging protocol called DIDComm (decentralized identifier communication) to exchange credentials between any wallet. Info Dive Deeper: Learn more about how to exchange credentials","title":"Send Credential to Allison"},{"location":"walkthroughs/vaccination/#store-credential-in-wallet","text":"Once Allison receives the credential, she or her wallet application can store it within her wallet. She can use any device that she's authorized to use with her wallet. Storing credentials securely is also important to maintaining Allison's privacy. Trinsic CLI Typescript C# Python Java Go trinsic --profile allison wallet insert-item --item vaccination-certificate-signed.json // Alice stores the credential in her cloud wallet. accountService . options . setAuthToken ( allison ); const itemId = await walletService . insertItem ( new InsertItemRequest () . setItemJson ( credential . getSignedDocumentJson ())); // Set active profile to 'allison' so we can manage her cloud wallet walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var insertItemResponse = await walletService . InsertItemAsync ( new () { ItemJson = credential . SignedDocumentJson }); var itemId = insertItemResponse . ItemId ; // searchWallet() { var walletItems = await walletService . SearchAsync ( new ()); // } _testOutputHelper . WriteLine ( $\"Last wallet item:\\n{walletItems.Items.Last()}\" ); // searchWalletSQL() { var walletItems2 = await walletService . SearchAsync ( new () { Query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" }) // } // SHARE CREDENTIAL // Allison shares the credential with the venue. // The venue has communicated with Allison the details of the credential // that they require expressed as a JSON-LD frame. // shareCredential() { // We'll read the request frame from a file and communicate this with Allison walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var proofRequestJson = await File . ReadAllTextAsync ( VaccinationCertificateFrame ); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential var credentialProof = await credentialsService . CreateProofAsync ( new () { ItemId = itemId , RevealDocumentJson = proofRequestJson }); _testOutputHelper . WriteLine ( \"Proof:\" ); _testOutputHelper . WriteLine ( credentialProof . ProofDocumentJson ); // } // VERIFY CREDENTIAL // verifyCredential() { // The airline verifies the credential walletService . Options . AuthToken = credentialsService . Options . AuthToken = airline ; // Check for valid signature var valid = await credentialsService . VerifyProofAsync ( new () { ProofDocumentJson = credentialProof . ProofDocumentJson }); _testOutputHelper . WriteLine ( $\"Verification result: {valid.IsValid}\" ); Assert . True ( valid . IsValid ); // } # Alice stores the credential in her cloud wallet. wallet_service . service_options . auth_token = allison # insertItemWallet() { insert_response = await wallet_service . insert_item ( request = InsertItemRequest ( item_json = credential ) ) # } item_id = insert_response . item_id print ( f \"item id = { item_id } \" ) # searchWallet() { wallet_items = await wallet_service . search () # } # searchWalletSQL() { wallet_items2 = await wallet_service . search ( request = SearchRequest ( query = \"SELECT c.id, c.type, c.data FROM c WHERE c.type = 'VerifiableCredential'\" )) # } print ( f \"last wallet item = { wallet_items . items [ - 1 ] } \" ) # shareCredential() { # Allison shares the credential with the venue. # The venue has communicated with Allison the details of the credential # that they require expressed as a JSON-LD frame. credentials_service . service_options . auth_token = allison wallet_service . service_options . auth_token = allison with open ( _vaccine_cert_frame_path (), \"r\" ) as fid2 : proof_request_json = \" \\n \" . join ( fid2 . readlines ()) # createProof() { proof_response = await credentials_service . create_proof ( request = CreateProofRequest ( reveal_document_json = proof_request_json , item_id = item_id ) ) # } credential_proof = proof_response . proof_document_json print ( f \"Proof: { credential_proof } \" ) # } # verifyCredential() { # The airline verifies the credential credentials_service . service_options . auth_token = airline wallet_service . service_options . auth_token = airline # verifyProof() { verify_result = await credentials_service . verify_proof ( request = VerifyProofRequest ( proof_document_json = credential_proof ) ) # } valid = verify_result . is_valid print ( f \"Verification result: { valid } \" ) assert valid is True # } # revokeCredential() { # update_status_response = await credentials_service.update_status(credential_status_id=status_id, revoked=True) # print(f\"UpdateStatusResponse: {update_status_response}\") # credential_status = await credentials_service.check_status(credential_status_id=status_id) # print(f\"Credential_status: {credential_status}\") # assert credential_status.revoked is True # } credentials_service . close () wallet_service . close () account_service . close () provider_service . close () if __name__ == \"__main__\" : asyncio . run ( vaccine_demo ()) // Alice stores the credential in her cloud wallet. var insertItemResponse = walletService . insertItem ( UniversalWalletOuterClass . InsertItemRequest . newBuilder (). setItemJson ( credential ). build ()). get (); final var itemId = insertItemResponse . getItemId (); System . out . println ( \"item id = \" + itemId ); walletService . SetToken ( allison ) failError ( t , \"error setting profile\" , err ) itemID , err := walletService . InsertItem ( context . Background (), & sdk . InsertItemRequest { ItemJson : credential . SignedDocumentJson }) failError ( t , \"error inserting item\" , err ) fmt . Println ( \"item id\" , itemID ) Note down the response item_id printed to the console for the next step. Info Reference: Insert Record","title":"Store Credential in Wallet"},{"location":"walkthroughs/vaccination/#create-a-proof-of-vaccination","text":"Before boarding an airplane, Allison must show a proof of vaccination. The request for this proof also comes in a form of JSON, in this case a JSON-LD frame. This request can be communicated using any exchange protocol. Again, we'll assume this was done offline. Let's save this request in a file named vaccination-certificate-frame.jsonld vaccination-certificate-frame.jsonld { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://w3id.org/vaccination/v1\" , \"https://w3id.org/security/bbs/v1\" ], \"type\" : [ \"VerifiableCredential\" , \"VaccinationCertificate\" ], \"@explicit\" : true , \"issuer\" : {}, \"credentialSubject\" : { \"@explicit\" : true , \"@type\" : \"VaccinationEvent\" , \"batchNumber\" : {}, \"countryOfVaccination\" : {} } } This request asks Allison to provide proof of valid vaccination certificate, including the issuer , batchNumber and countryOfVaccination fields. Allison can use the Create Proof functions to build a proof that will share only the requested fields. Now let's create a proof for Allison. She may choose to generate this proof before going to the airport, or might generate it right as she boards. Trinsic CLI Typescript C# Python Java Go Replace the <item_id> in the generate proof command below with the output from the insert_item above. trinsic --profile allison issuer create-proof --document-id \"<item-id>\" --out vaccination-certificate-partial-proof.json --reveal-document data/vaccination-certificate-frame.json // Allison shares the credential with the venue. // The venue has communicated with Allison the details of the credential // that they require expressed as a JSON-LD frame. credentialService . options . setAuthToken ( allison ); const proofRequestJson = getVaccineCertFrameJSON (); const proof = await credentialService . createProof ( new CreateProofRequest () . setItemId ( itemId . getItemId ()) . setRevealDocumentJson ( JSON . stringify ( proofRequestJson ))); // We'll read the request frame from a file and communicate this with Allison walletService . Options . AuthToken = credentialsService . Options . AuthToken = allison ; var proofRequestJson = await File . ReadAllTextAsync ( VaccinationCertificateFrame ); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential var credentialProof = await credentialsService . CreateProofAsync ( new () { ItemId = itemId , RevealDocumentJson = proofRequestJson }); _testOutputHelper . WriteLine ( \"Proof:\" ); _testOutputHelper . WriteLine ( credentialProof . ProofDocumentJson ); # Allison shares the credential with the venue. # The venue has communicated with Allison the details of the credential # that they require expressed as a JSON-LD frame. credentials_service . service_options . auth_token = allison wallet_service . service_options . auth_token = allison with open ( _vaccine_cert_frame_path (), \"r\" ) as fid2 : proof_request_json = \" \\n \" . join ( fid2 . readlines ()) # createProof() { proof_response = await credentials_service . create_proof ( request = CreateProofRequest ( reveal_document_json = proof_request_json , item_id = item_id ) ) # } credential_proof = proof_response . proof_document_json print ( f \"Proof: { credential_proof } \" ) // Allison shares the credential with the venue. // The venue has communicated with Allison the details of the credential // that they require expressed as a JSON-LD frame. credentialsService . setProfile ( allison ); var proofRequestJson = Files . readString ( vaccineCertFramePath ()); var createProofResponse = credentialsService . createProof ( VerifiableCredentials . CreateProofRequest . newBuilder (). setItemId ( itemId ). setRevealDocumentJson ( proofRequestJson ). build ()). get (); var credentialProof = createProofResponse . getProofDocumentJson (); System . out . println ( \"Proof: \" + credentialProof ); walletService . SetToken ( allison ) failError ( t , \"error reading file\" , err ) fileContent2 , err := ioutil . ReadFile ( GetVaccineCertFramePath ()) failError ( t , \"error reading file\" , err ) req := & sdk . CreateProofRequest { RevealDocumentJson : string ( fileContent2 ), Proof : & sdk . CreateProofRequest_ItemId { ItemId : itemID }, } credentialService . SetToken ( allison ) credentialProof , err := credentialService . CreateProof ( context . Background (), req ) failError ( t , \"error creating proof\" , err ) fmt . Println ( \"Credential proof\" , credentialProof ) Take a look at the proof. Notice how only the attributes included in the frame are included with the proof. Allison sends this proof to the airline for them to verify. Info Reference: Create Proof","title":"Create a Proof of Vaccination"},{"location":"walkthroughs/vaccination/#verify-proof","text":"Once the airline receives the proof, they can now verify it to ensure its authenticity. Because Allison sent a proof of her vaccination credential and not the credential itself, the airline only receives its required information. Trinsic CLI Typescript C# Python Java Go trinsic --profile airline issuer verify-proof --proof-document vaccination-certificate-partial-proof.json // The airline verifies the credential credentialService . options . setAuthToken ( airline ); const verifyResponse = await credentialService . verifyProof ( new VerifyProofRequest () . setProofDocumentJson ( proof . getProofDocumentJson ())); // The airline verifies the credential walletService . Options . AuthToken = credentialsService . Options . AuthToken = airline ; // Check for valid signature var valid = await credentialsService . VerifyProofAsync ( new () { ProofDocumentJson = credentialProof . ProofDocumentJson }); _testOutputHelper . WriteLine ( $\"Verification result: {valid.IsValid}\" ); Assert . True ( valid . IsValid ); # The airline verifies the credential credentials_service . service_options . auth_token = airline wallet_service . service_options . auth_token = airline # verifyProof() { verify_result = await credentials_service . verify_proof ( request = VerifyProofRequest ( proof_document_json = credential_proof ) ) # } valid = verify_result . is_valid print ( f \"Verification result: { valid } \" ) assert valid is True // The airline verifies the credential credentialsService . setProfile ( airline ); var verifyProofResponse = credentialsService . verifyProof ( VerifiableCredentials . VerifyProofRequest . newBuilder (). setProofDocumentJson ( credentialProof ). build ()). get (); var isValid = verifyProofResponse . getIsValid (); System . out . println ( \"Verification result: \" + isValid ); Assertions . assertTrue ( isValid ); walletService . SetToken ( airline ) failError ( t , \"error setting profile\" , err ) valid , err := credentialService . VerifyProof ( context . Background (), & sdk . VerifyProofRequest { ProofDocumentJson : credential . SignedDocumentJson }) failError ( t , \"error verifying proof\" , err ) fmt . Println ( \"Validation result\" , valid ) if valid != true { t . Fail () } Watch for the result of true to know that the credential successfully passed all of the verification processes. Info Reference: Verify Proof","title":"Verify Proof"},{"location":"walkthroughs/vaccination/#full-source-code","text":"Typescript C# Python Java browser node This sample is available in our dotnet directory. <!-- ??? You can also run the code using Replit and inspect the results. example \"Run example in Replit\" <iframe frameborder=\"0\" width=\"100%\" height=\"650px\" src=\"https://replit.com/@trinsic/VaccinationSample-dotnet?lite=true\"></iframe> --> This sample is available as ecosystem_demo.py This sample is available in the Java directory.","title":"Full Source Code"},{"location":"walkthroughs/vaccination/#next-steps","text":"Congratulations! If you've completed all the steps of this walkthrough, you've just created a mini ecosystem of issuers, verifiers, and holders all exchanging credentials. Depending on your goals, there are a couple of possible next steps to take. Try out a sample app Learn more about wallets, credentials, templates, and ecosystems Review the SDK Reference","title":"Next Steps:"},{"location":"walkthroughs/vaccination/#sample-applications","text":"We have language specific sample applications that you can run to understand how the Trinsic SDK works in a development environment. Typescript C# Python The tests folder in the [browser] This sample is available in our dotnet subdirectory. You can also simply run the code using Replit and inspect the results. This sample is available in the python directory Java This sample is available in our Github repo in the java directory .","title":"Sample Applications"},{"location":"web/","text":"The Trinsic Javascript / Web SDK \u00b6 The Trinsic Web SDK makes it easy to interact with the Trinsic API from any client-side web application. You can find the SDKs source on Github . Installation \u00b6 Install the package for Node or Browser from npmjs.com Install npm i @trinsic/trinsic Create new project \u00b6 Let's create a new console app that we will use to add our sample code mkdir web-sample && cd web-sample && npm init You can select all the defaults for the node project. Add the required dependencies npm i @trinsic/trinsic-web npm i --save-dev http-server webpack webpack-cli Configure Webpack \u00b6 After installing the dependencies you'll need a configuration file for webpack. Create a file called webpack.config.js at the root of your project and then copy and paste this into that file const path = require ( 'path' ); module . exports = { mode : 'development' , entry : './src/index.js' , output : { path : path . resolve ( __dirname , './src' ), filename : 'bundle.js' , } }; Configure Webpack for React \u00b6 If using React you may need to start your project with craco Install Craco npm i @craco/craco Next change your react scripts in your package.json file \"scripts\" : { - \"start\" : \"react-scripts start\" , + \"start\" : \"craco start\" , - \"build\" : \"react-scripts build\" , + \"build\" : \"craco build\" - \"test\" : \"react-scripts test\" , + \"test\" : \"craco test\" } Finally you will need to add a craco configuration file called craco.config.js and add the following: // craco.config.js const { addBeforeLoader , loaderByName } = require ( '@craco/craco' ); module . exports = { webpack : { configure : ( webpackConfig ) => { const wasmExtensionRegExp = /\\.wasm$/ ; webpackConfig . resolve . extensions . push ( '.wasm' ); webpackConfig . module . rules . forEach (( rule ) => { ( rule . oneOf || []). forEach (( oneOf ) => { if ( oneOf . loader && oneOf . loader . indexOf ( 'file-loader' ) >= 0 ) { oneOf . exclude . push ( wasmExtensionRegExp ); } }); }); const wasmLoader = { test : /\\.wasm$/ , exclude : /node_modules/ , loaders : [ 'wasm-loader' ], }; addBeforeLoader ( webpackConfig , loaderByName ( 'file-loader' ), wasmLoader ); return webpackConfig ; } } } This allows react loaders to properly load in some of our needed .wasm files. Set up Website \u00b6 Create a simple html page with a script tag referencing the webpack bundle that will be built after completing the sample code. Note that you will not have the bundle.js file yet because it will be generated from the index.js file you create. <!DOCTYPE html> < html lang = \"en\" > < head > < title > Web Sample </ title > < meta charset = \"UTF-8\" /> < meta name = \"viewport\" content = \"width=device-width,initial-scale=1\" /> < meta name = \"description\" content = \"\" /> </ head > < body > < h1 > Web Sample </ h1 > < div id = \"wallet\" ></ div > </ body > < script src = \"../bundle.js\" ></ script > </ html > Your file structure should look like this web-sample src index.html index.js package.json webpack.config.js Next Steps \u00b6 Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API","title":"Browser"},{"location":"web/#the-trinsic-javascript-web-sdk","text":"The Trinsic Web SDK makes it easy to interact with the Trinsic API from any client-side web application. You can find the SDKs source on Github .","title":"The Trinsic Javascript / Web SDK"},{"location":"web/#installation","text":"Install the package for Node or Browser from npmjs.com Install npm i @trinsic/trinsic","title":"Installation"},{"location":"web/#create-new-project","text":"Let's create a new console app that we will use to add our sample code mkdir web-sample && cd web-sample && npm init You can select all the defaults for the node project. Add the required dependencies npm i @trinsic/trinsic-web npm i --save-dev http-server webpack webpack-cli","title":"Create new project"},{"location":"web/#configure-webpack","text":"After installing the dependencies you'll need a configuration file for webpack. Create a file called webpack.config.js at the root of your project and then copy and paste this into that file const path = require ( 'path' ); module . exports = { mode : 'development' , entry : './src/index.js' , output : { path : path . resolve ( __dirname , './src' ), filename : 'bundle.js' , } };","title":"Configure Webpack"},{"location":"web/#set-up-website","text":"Create a simple html page with a script tag referencing the webpack bundle that will be built after completing the sample code. Note that you will not have the bundle.js file yet because it will be generated from the index.js file you create. <!DOCTYPE html> < html lang = \"en\" > < head > < title > Web Sample </ title > < meta charset = \"UTF-8\" /> < meta name = \"viewport\" content = \"width=device-width,initial-scale=1\" /> < meta name = \"description\" content = \"\" /> </ head > < body > < h1 > Web Sample </ h1 > < div id = \"wallet\" ></ div > </ body > < script src = \"../bundle.js\" ></ script > </ html > Your file structure should look like this web-sample src index.html index.js package.json webpack.config.js","title":"Set up Website"},{"location":"web/#next-steps","text":"Once the SDK is installed and configured, you're ready to start building! We recommend going through the walkthrough next. If you're ready to dive into building your ecosystem, check out our API Reference Start Walkthrough Explore API","title":"Next Steps"}]}